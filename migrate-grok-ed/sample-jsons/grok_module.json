{
  "module": {
    "id": 7173,
    "slug": "unimelb-comp10002-2022-s1-chapter10",
    "title": "Chapter 10: Dynamic Structures (FOA only)",
    "authoring_state": 3,
    "default_language": 11,
    "default_slide_layout": 0,
    "default_feedback_style": 0,
    "content": [
      {
        "title": "Exercises",
        "slides": [
          {
            "id": "c5838ac1-3c99-42aa-8c61-66557c0b81ac",
            "title": "sizeof (Figure 10.1)",
            "type": 0,
            "layout": 2,
            "feedback_style": 0,
            "purpose": "",
            "content_raw": "#markdown\n\n`sizeof` is a function evaluated at compile-time that returns the number of bytes used to store the indicated type or variable.\n\nExecute the following program from Figure 10.1 (page 164) of PPSAA by clicking the Run button.\n```\n/* sizeof.c - Show the use of sizeof.\n * Alistair Moffat, PPSAA Figure 10.1, December 2012\n * (c) University of Melbourne */\n#include <stdio.h>\n#include <stdlib.h>\n\nint\nmain(int argc, char *argv[]) {\n    double A[10]; char *p=\"mary mary quite contrary\";\n    printf(\"sizeof(char)   = %2u\\n\", sizeof(char));\n    printf(\"sizeof(int)    = %2u\\n\", sizeof(int));\n    printf(\"sizeof(float)  = %2u\\n\", sizeof(float));\n    printf(\"sizeof(double) = %2u\\n\", sizeof(double));\n    printf(\"sizeof(A)      = %2u\\n\", sizeof(A));\n    printf(\"sizeof(*A)     = %2u\\n\", sizeof(*A));\n    printf(\"sizeof(p)      = %2u\\n\", sizeof(p));\n    printf(\"sizeof(*p)     = %2u\\n\", sizeof(*p));\n    return 0;\n}\n```\n```eg:last;path:Makefile;readonly;hidden;\nCC = clang\nCFLAGS = -Wall -Wno-unused-parameter -std=c11\n\nPROGRAM = program\nSOURCE_FILES = $(shell find . -type f -name '*.c')\nOBJECT_FILES = $(SOURCE_FILES:.c=.o)\n\n.PHONY: all build clean run\n\nall: build\n\nbuild: $(PROGRAM)\n\nclean:\n\trm -f $(PROGRAM) $(OBJECT_FILES)\n\nrun: build\n\t./$(PROGRAM)\n\n$(PROGRAM): $(OBJECT_FILES)\n\t$(CC) -o $@ $^ $(LDFLAGS)\n```\n\nIn the textbook, the output is:\n```lang:out\nsizeof(char)   =  1\nsizeof(int)    =  4\nsizeof(float)  =  4\nsizeof(double) =  8\nsizeof(A)      = 80\nsizeof(*A)     =  8\nsizeof(p)      =  8\nsizeof(*p)     =  1\n\n```\n\nDoes this match with the output as executed on Grok?  What differences are there, and why?\n",
            "rows": [
              {
                "left": "#markdown\n\n`sizeof` is a function evaluated at compile-time that returns the number of bytes used to store the indicated type or variable.\n\nExecute the following program from Figure 10.1 (page 164) of PPSAA by clicking the Run button.\n```\n/* sizeof.c - Show the use of sizeof.\n * Alistair Moffat, PPSAA Figure 10.1, December 2012\n * (c) University of Melbourne */\n#include <stdio.h>\n#include <stdlib.h>\n\nint\nmain(int argc, char *argv[]) {\n    double A[10]; char *p=\"mary mary quite contrary\";\n    printf(\"sizeof(char)   = %2u\\n\", sizeof(char));\n    printf(\"sizeof(int)    = %2u\\n\", sizeof(int));\n    printf(\"sizeof(float)  = %2u\\n\", sizeof(float));\n    printf(\"sizeof(double) = %2u\\n\", sizeof(double));\n    printf(\"sizeof(A)      = %2u\\n\", sizeof(A));\n    printf(\"sizeof(*A)     = %2u\\n\", sizeof(*A));\n    printf(\"sizeof(p)      = %2u\\n\", sizeof(p));\n    printf(\"sizeof(*p)     = %2u\\n\", sizeof(*p));\n    return 0;\n}\n```\n```eg:last;path:Makefile;readonly;hidden;\nCC = clang\nCFLAGS = -Wall -Wno-unused-parameter -std=c11\n\nPROGRAM = program\nSOURCE_FILES = $(shell find . -type f -name '*.c')\nOBJECT_FILES = $(SOURCE_FILES:.c=.o)\n\n.PHONY: all build clean run\n\nall: build\n\nbuild: $(PROGRAM)\n\nclean:\n\trm -f $(PROGRAM) $(OBJECT_FILES)\n\nrun: build\n\t./$(PROGRAM)\n\n$(PROGRAM): $(OBJECT_FILES)\n\t$(CC) -o $@ $^ $(LDFLAGS)\n```\n\nIn the textbook, the output is:\n```lang:out\nsizeof(char)   =  1\nsizeof(int)    =  4\nsizeof(float)  =  4\nsizeof(double) =  8\nsizeof(A)      = 80\nsizeof(*A)     =  8\nsizeof(p)      =  8\nsizeof(*p)     =  1\n\n```\n\nDoes this match with the output as executed on Grok?  What differences are there, and why?\n"
              }
            ],
            "content_rendered": "<p><code data-lang=\"c\">sizeof</code> is a function evaluated at compile-time that returns the number of bytes used to store the indicated type or variable.</p>\n<p>Execute the following program from Figure 10.1 (page 164) of PPSAA by clicking the Run button.</p>\n<pre class=\"js-editor\" data-eg-id=\"unimelb-comp10002-2022-s1-chapter10-0-0-0\"><code data-lang=\"c\">/* sizeof.c - Show the use of sizeof.\n * Alistair Moffat, PPSAA Figure 10.1, December 2012\n * (c) University of Melbourne */\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint\nmain(int argc, char *argv[]) {\n    double A[10]; char *p=&quot;mary mary quite contrary&quot;;\n    printf(&quot;sizeof(char)   = %2u\\n&quot;, sizeof(char));\n    printf(&quot;sizeof(int)    = %2u\\n&quot;, sizeof(int));\n    printf(&quot;sizeof(float)  = %2u\\n&quot;, sizeof(float));\n    printf(&quot;sizeof(double) = %2u\\n&quot;, sizeof(double));\n    printf(&quot;sizeof(A)      = %2u\\n&quot;, sizeof(A));\n    printf(&quot;sizeof(*A)     = %2u\\n&quot;, sizeof(*A));\n    printf(&quot;sizeof(p)      = %2u\\n&quot;, sizeof(p));\n    printf(&quot;sizeof(*p)     = %2u\\n&quot;, sizeof(*p));\n    return 0;\n}\n</code></pre>\n<pre class=\"js-file-editor\" data-eg-id=\"unimelb-comp10002-2022-s1-chapter10-0-0-0\" data-path=\"Makefile\" data-readonly=\"true\" style=\"display: none\"><code data-lang=\"c\">CC = clang\nCFLAGS = -Wall -Wno-unused-parameter -std=c11\n\nPROGRAM = program\nSOURCE_FILES = $(shell find . -type f -name '*.c')\nOBJECT_FILES = $(SOURCE_FILES:.c=.o)\n\n.PHONY: all build clean run\n\nall: build\n\nbuild: $(PROGRAM)\n\nclean:\n\trm -f $(PROGRAM) $(OBJECT_FILES)\n\nrun: build\n\t./$(PROGRAM)\n\n$(PROGRAM): $(OBJECT_FILES)\n\t$(CC) -o $@ $^ $(LDFLAGS)\n</code></pre>\n<p>In the textbook, the output is:</p>\n<pre class=\"js-editor\" data-eg-id=\"unimelb-comp10002-2022-s1-chapter10-0-0-1\"><code data-lang=\"out\">sizeof(char)   =  1\nsizeof(int)    =  4\nsizeof(float)  =  4\nsizeof(double) =  8\nsizeof(A)      = 80\nsizeof(*A)     =  8\nsizeof(p)      =  8\nsizeof(*p)     =  1\n\n</code></pre>\n<p>Does this match with the output as executed on Grok?  What differences are there, and why?</p>",
            "notes_rendered": ""
          },
          {
            "id": "4e567e46-967b-4088-9dbd-20fbd3c22c71",
            "title": "malloc and free (Figure 10.2)",
            "type": 0,
            "layout": 2,
            "feedback_style": 0,
            "purpose": "",
            "content_raw": "#markdown\n\n`malloc` returns a pointer to a segment of memory of the requested size in bytes, or `NULL` if no such segment can be allocated.\n\n`free` releases a previously allocated segment of memory back to the memory management system.   Unless a program requires all allocated memory through to termination, each call to `malloc` should be matched by a later call to `free`.\n\nExecute the following program from Figure 10.2 (page 165) of PPSAA by clicking the Run button.\n```\n/* malloc.c - Show the use of malloc and free.\n * Alistair Moffat, PPSAA Figure 10.2, December 2012\n * (c) University of Melbourne */\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdlib.h>\n\n#define PTRS 5\n\nint\nmain(int argc, char *argv[]) {\n\tchar *p[PTRS];\n\tsize_t nbytes = 10;\n\n\t/* try to allocate an array of pointers */\n\tfor (int i = 0; i < PTRS; i++) {\n\t\tprintf(\"malloc of %10lu bytes \", nbytes);\n\t\tif ((p[i] = (char *)malloc(nbytes)) == NULL) {\n\t\t\tprintf(\"failed\\n\");\n\t\t} else {\n\t\t\tprintf(\"succeeded\\n\");\n\t\t}\n\t\tnbytes *= 100;\n\t}\n\t/* now free all the memory that did get allocated */\n\tfor (int i = 0; i < PTRS; i++) {\n\t\tif (p[i]) {\n\t\t\tfree(p[i]);\n\t\t\tp[i] = NULL;\n\t\t}\n\t}\n\treturn 0;\n}\n```\n```eg:last;path:Makefile;readonly;hidden;\nCC = clang\nCFLAGS = -Wall -Wno-unused-parameter -std=c11\n\nPROGRAM = program\nSOURCE_FILES = $(shell find . -type f -name '*.c')\nOBJECT_FILES = $(SOURCE_FILES:.c=.o)\n\n.PHONY: all build clean run\n\nall: build\n\nbuild: $(PROGRAM)\n\nclean:\n\trm -f $(PROGRAM) $(OBJECT_FILES)\n\nrun: build\n\t./$(PROGRAM)\n\n$(PROGRAM): $(OBJECT_FILES)\n\t$(CC) -o $@ $^ $(LDFLAGS)\n```\n\nIn the textbook, the output is:\n```lang:out\nmalloc of         10 bytes succeeded\nmalloc of       1000 bytes succeeded\nmalloc of     100000 bytes succeeded\nmalloc of   10000000 bytes succeeded\nmalloc of 1000000000 bytes succeeded\n\n```\n\nDoes this match with the output as executed on Grok?  How much memory can be accessed by a C program on Grok?\n",
            "rows": [
              {
                "left": "#markdown\n\n`malloc` returns a pointer to a segment of memory of the requested size in bytes, or `NULL` if no such segment can be allocated.\n\n`free` releases a previously allocated segment of memory back to the memory management system.   Unless a program requires all allocated memory through to termination, each call to `malloc` should be matched by a later call to `free`.\n\nExecute the following program from Figure 10.2 (page 165) of PPSAA by clicking the Run button.\n```\n/* malloc.c - Show the use of malloc and free.\n * Alistair Moffat, PPSAA Figure 10.2, December 2012\n * (c) University of Melbourne */\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdlib.h>\n\n#define PTRS 5\n\nint\nmain(int argc, char *argv[]) {\n\tchar *p[PTRS];\n\tsize_t nbytes = 10;\n\n\t/* try to allocate an array of pointers */\n\tfor (int i = 0; i < PTRS; i++) {\n\t\tprintf(\"malloc of %10lu bytes \", nbytes);\n\t\tif ((p[i] = (char *)malloc(nbytes)) == NULL) {\n\t\t\tprintf(\"failed\\n\");\n\t\t} else {\n\t\t\tprintf(\"succeeded\\n\");\n\t\t}\n\t\tnbytes *= 100;\n\t}\n\t/* now free all the memory that did get allocated */\n\tfor (int i = 0; i < PTRS; i++) {\n\t\tif (p[i]) {\n\t\t\tfree(p[i]);\n\t\t\tp[i] = NULL;\n\t\t}\n\t}\n\treturn 0;\n}\n```\n```eg:last;path:Makefile;readonly;hidden;\nCC = clang\nCFLAGS = -Wall -Wno-unused-parameter -std=c11\n\nPROGRAM = program\nSOURCE_FILES = $(shell find . -type f -name '*.c')\nOBJECT_FILES = $(SOURCE_FILES:.c=.o)\n\n.PHONY: all build clean run\n\nall: build\n\nbuild: $(PROGRAM)\n\nclean:\n\trm -f $(PROGRAM) $(OBJECT_FILES)\n\nrun: build\n\t./$(PROGRAM)\n\n$(PROGRAM): $(OBJECT_FILES)\n\t$(CC) -o $@ $^ $(LDFLAGS)\n```\n\nIn the textbook, the output is:\n```lang:out\nmalloc of         10 bytes succeeded\nmalloc of       1000 bytes succeeded\nmalloc of     100000 bytes succeeded\nmalloc of   10000000 bytes succeeded\nmalloc of 1000000000 bytes succeeded\n\n```\n\nDoes this match with the output as executed on Grok?  How much memory can be accessed by a C program on Grok?\n"
              }
            ],
            "content_rendered": "<p><code data-lang=\"c\">malloc</code> returns a pointer to a segment of memory of the requested size in bytes, or <code data-lang=\"c\">NULL</code> if no such segment can be allocated.</p>\n<p><code data-lang=\"c\">free</code> releases a previously allocated segment of memory back to the memory management system.   Unless a program requires all allocated memory through to termination, each call to <code data-lang=\"c\">malloc</code> should be matched by a later call to <code data-lang=\"c\">free</code>.</p>\n<p>Execute the following program from Figure 10.2 (page 165) of PPSAA by clicking the Run button.</p>\n<pre class=\"js-editor\" data-eg-id=\"unimelb-comp10002-2022-s1-chapter10-0-1-0\"><code data-lang=\"c\">/* malloc.c - Show the use of malloc and free.\n * Alistair Moffat, PPSAA Figure 10.2, December 2012\n * (c) University of Melbourne */\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;stdlib.h&gt;\n\n#define PTRS 5\n\nint\nmain(int argc, char *argv[]) {\n\tchar *p[PTRS];\n\tsize_t nbytes = 10;\n\n\t/* try to allocate an array of pointers */\n\tfor (int i = 0; i &lt; PTRS; i++) {\n\t\tprintf(&quot;malloc of %10lu bytes &quot;, nbytes);\n\t\tif ((p[i] = (char *)malloc(nbytes)) == NULL) {\n\t\t\tprintf(&quot;failed\\n&quot;);\n\t\t} else {\n\t\t\tprintf(&quot;succeeded\\n&quot;);\n\t\t}\n\t\tnbytes *= 100;\n\t}\n\t/* now free all the memory that did get allocated */\n\tfor (int i = 0; i &lt; PTRS; i++) {\n\t\tif (p[i]) {\n\t\t\tfree(p[i]);\n\t\t\tp[i] = NULL;\n\t\t}\n\t}\n\treturn 0;\n}\n</code></pre>\n<pre class=\"js-file-editor\" data-eg-id=\"unimelb-comp10002-2022-s1-chapter10-0-1-0\" data-path=\"Makefile\" data-readonly=\"true\" style=\"display: none\"><code data-lang=\"c\">CC = clang\nCFLAGS = -Wall -Wno-unused-parameter -std=c11\n\nPROGRAM = program\nSOURCE_FILES = $(shell find . -type f -name '*.c')\nOBJECT_FILES = $(SOURCE_FILES:.c=.o)\n\n.PHONY: all build clean run\n\nall: build\n\nbuild: $(PROGRAM)\n\nclean:\n\trm -f $(PROGRAM) $(OBJECT_FILES)\n\nrun: build\n\t./$(PROGRAM)\n\n$(PROGRAM): $(OBJECT_FILES)\n\t$(CC) -o $@ $^ $(LDFLAGS)\n</code></pre>\n<p>In the textbook, the output is:</p>\n<pre class=\"js-editor\" data-eg-id=\"unimelb-comp10002-2022-s1-chapter10-0-1-1\"><code data-lang=\"out\">malloc of         10 bytes succeeded\nmalloc of       1000 bytes succeeded\nmalloc of     100000 bytes succeeded\nmalloc of   10000000 bytes succeeded\nmalloc of 1000000000 bytes succeeded\n\n</code></pre>\n<p>Does this match with the output as executed on Grok?  How much memory can be accessed by a C program on Grok?</p>",
            "notes_rendered": ""
          },
          {
            "id": "b0220f8a-9c91-470c-8ca3-a3ef6b483a01",
            "title": "Ex10.x1: Dynamic memory allocation",
            "type": 1,
            "layout": 0,
            "feedback_style": 0,
            "purpose": "",
            "problem_id": 15556,
            "authoring_notes": "",
            "tutor_notes": ""
          },
          {
            "id": "2da99af2-b4be-4206-aeb1-b1667681a385",
            "title": "Dynamic arrays and realloc (Figure 10.3)",
            "type": 0,
            "layout": 2,
            "feedback_style": 0,
            "purpose": "",
            "content_raw": "#markdown\n\n```\n/* realloc.c - Break the input up into a sequence of words, and only\n   report the unique ones. Uses malloc and realloc to help cope with very\n   large input files.\n   Alistair Moffat - PPSAA Figure 10.3 - December 2012\n*/\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n\n#define MAXCHARS 1000    /* max chars per word */\n#define INITIAL   100    /* initial size of word array */\n\ntypedef char word_t[MAXCHARS+1];\nint getword(word_t W, int limit);\nvoid exit_if_null(void *ptr, char *msg);\n\nint\nmain(int argc, char *argv[]) {\n\tword_t one_word;\n\tchar **all_words;\n\tsize_t current_size=INITIAL;\n\tint numdistinct=0, totwords=0, i, found;\n\tall_words = (char**)malloc(INITIAL*sizeof(*all_words));\n\texit_if_null(all_words, \"initial allocation\");\n\twhile (getword(one_word, MAXCHARS) != EOF) {\n\t\ttotwords = totwords+1;\n\t\t/* linear search in array of previous words... */\n\t\tfound = 0;\n\t\tfor (i=0; i<numdistinct && !found; i++) {\n\t\t\tfound = (strcmp(one_word, all_words[i]) == 0);\n\t\t}\n\t\tif (!found) {\n\t\t\t/* a new word exists, but is there space? */\n\t\t\tif (numdistinct == current_size) {\n\t\t\t\tcurrent_size *= 2;\n\t\t\t\tall_words = realloc(all_words, \n\t\t\t\t\tcurrent_size*sizeof(*all_words));\n\t\t\t\texit_if_null(all_words, \"reallocation\");\n\t\t\t}\n\t\t\t/* ok, there is definitely space in array */\n\t\t\tall_words[numdistinct] =\n\t\t\t\t(char*)malloc(1+strlen(one_word));\n\t\t\texit_if_null(all_words[numdistinct],\n\t\t\t\t\"string malloc\");\n\t\t\t/* and there is also a space for the new word */\n\t\t\tstrcpy(all_words[numdistinct], one_word);\n\t\t\tnumdistinct += 1;\n\t\t}\n\t}\n\tprintf(\"%d words read\\n\", totwords);\n\tfor (i=0; i<numdistinct; i++) {\n\t\tprintf(\"word #%d is \\\"%s\\\"\\n\", i, all_words[i]);\n\t\tfree(all_words[i]);\n\t\tall_words[i] = NULL;\n\t}\n\tfree(all_words);\n\tall_words = NULL;\n\treturn 0;\n}\n\nvoid\nexit_if_null(void *ptr, char *msg) {\n\tif (!ptr) {\n\t\tprintf(\"unexpected null pointer: %s\\n\", msg);\n\t\texit(EXIT_FAILURE);\n\t}\n}\n\n#include \"getword.c\"\n```",
            "rows": [
              {
                "left": "#markdown\n\n```\n/* realloc.c - Break the input up into a sequence of words, and only\n   report the unique ones. Uses malloc and realloc to help cope with very\n   large input files.\n   Alistair Moffat - PPSAA Figure 10.3 - December 2012\n*/\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n\n#define MAXCHARS 1000    /* max chars per word */\n#define INITIAL   100    /* initial size of word array */\n\ntypedef char word_t[MAXCHARS+1];\nint getword(word_t W, int limit);\nvoid exit_if_null(void *ptr, char *msg);\n\nint\nmain(int argc, char *argv[]) {\n\tword_t one_word;\n\tchar **all_words;\n\tsize_t current_size=INITIAL;\n\tint numdistinct=0, totwords=0, i, found;\n\tall_words = (char**)malloc(INITIAL*sizeof(*all_words));\n\texit_if_null(all_words, \"initial allocation\");\n\twhile (getword(one_word, MAXCHARS) != EOF) {\n\t\ttotwords = totwords+1;\n\t\t/* linear search in array of previous words... */\n\t\tfound = 0;\n\t\tfor (i=0; i<numdistinct && !found; i++) {\n\t\t\tfound = (strcmp(one_word, all_words[i]) == 0);\n\t\t}\n\t\tif (!found) {\n\t\t\t/* a new word exists, but is there space? */\n\t\t\tif (numdistinct == current_size) {\n\t\t\t\tcurrent_size *= 2;\n\t\t\t\tall_words = realloc(all_words, \n\t\t\t\t\tcurrent_size*sizeof(*all_words));\n\t\t\t\texit_if_null(all_words, \"reallocation\");\n\t\t\t}\n\t\t\t/* ok, there is definitely space in array */\n\t\t\tall_words[numdistinct] =\n\t\t\t\t(char*)malloc(1+strlen(one_word));\n\t\t\texit_if_null(all_words[numdistinct],\n\t\t\t\t\"string malloc\");\n\t\t\t/* and there is also a space for the new word */\n\t\t\tstrcpy(all_words[numdistinct], one_word);\n\t\t\tnumdistinct += 1;\n\t\t}\n\t}\n\tprintf(\"%d words read\\n\", totwords);\n\tfor (i=0; i<numdistinct; i++) {\n\t\tprintf(\"word #%d is \\\"%s\\\"\\n\", i, all_words[i]);\n\t\tfree(all_words[i]);\n\t\tall_words[i] = NULL;\n\t}\n\tfree(all_words);\n\tall_words = NULL;\n\treturn 0;\n}\n\nvoid\nexit_if_null(void *ptr, char *msg) {\n\tif (!ptr) {\n\t\tprintf(\"unexpected null pointer: %s\\n\", msg);\n\t\texit(EXIT_FAILURE);\n\t}\n}\n\n#include \"getword.c\"\n```"
              }
            ],
            "content_rendered": "<pre class=\"js-editor\" data-eg-id=\"unimelb-comp10002-2022-s1-chapter10-0-3-0\"><code data-lang=\"c\">/* realloc.c - Break the input up into a sequence of words, and only\n   report the unique ones. Uses malloc and realloc to help cope with very\n   large input files.\n   Alistair Moffat - PPSAA Figure 10.3 - December 2012\n*/\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;assert.h&gt;\n\n#define MAXCHARS 1000    /* max chars per word */\n#define INITIAL   100    /* initial size of word array */\n\ntypedef char word_t[MAXCHARS+1];\nint getword(word_t W, int limit);\nvoid exit_if_null(void *ptr, char *msg);\n\nint\nmain(int argc, char *argv[]) {\n\tword_t one_word;\n\tchar **all_words;\n\tsize_t current_size=INITIAL;\n\tint numdistinct=0, totwords=0, i, found;\n\tall_words = (char**)malloc(INITIAL*sizeof(*all_words));\n\texit_if_null(all_words, &quot;initial allocation&quot;);\n\twhile (getword(one_word, MAXCHARS) != EOF) {\n\t\ttotwords = totwords+1;\n\t\t/* linear search in array of previous words... */\n\t\tfound = 0;\n\t\tfor (i=0; i&lt;numdistinct &amp;&amp; !found; i++) {\n\t\t\tfound = (strcmp(one_word, all_words[i]) == 0);\n\t\t}\n\t\tif (!found) {\n\t\t\t/* a new word exists, but is there space? */\n\t\t\tif (numdistinct == current_size) {\n\t\t\t\tcurrent_size *= 2;\n\t\t\t\tall_words = realloc(all_words, \n\t\t\t\t\tcurrent_size*sizeof(*all_words));\n\t\t\t\texit_if_null(all_words, &quot;reallocation&quot;);\n\t\t\t}\n\t\t\t/* ok, there is definitely space in array */\n\t\t\tall_words[numdistinct] =\n\t\t\t\t(char*)malloc(1+strlen(one_word));\n\t\t\texit_if_null(all_words[numdistinct],\n\t\t\t\t&quot;string malloc&quot;);\n\t\t\t/* and there is also a space for the new word */\n\t\t\tstrcpy(all_words[numdistinct], one_word);\n\t\t\tnumdistinct += 1;\n\t\t}\n\t}\n\tprintf(&quot;%d words read\\n&quot;, totwords);\n\tfor (i=0; i&lt;numdistinct; i++) {\n\t\tprintf(&quot;word #%d is \\&quot;%s\\&quot;\\n&quot;, i, all_words[i]);\n\t\tfree(all_words[i]);\n\t\tall_words[i] = NULL;\n\t}\n\tfree(all_words);\n\tall_words = NULL;\n\treturn 0;\n}\n\nvoid\nexit_if_null(void *ptr, char *msg) {\n\tif (!ptr) {\n\t\tprintf(&quot;unexpected null pointer: %s\\n&quot;, msg);\n\t\texit(EXIT_FAILURE);\n\t}\n}\n\n#include &quot;getword.c&quot;\n</code></pre>",
            "notes_rendered": ""
          },
          {
            "id": "662ca32e-499d-43cc-bb24-4be42fbb48c8",
            "title": "listops.h (Figure 10.4)",
            "type": 0,
            "layout": 0,
            "feedback_style": 0,
            "purpose": "",
            "content_raw": "#markdown\n\nThe `listops.h` library has been included here, along with an example program.  Feel free to run it and inspect the code to see how it works.\n\n```path:listops.h;norun;eg:listops\n/* list operations\n * Alistair Moffat, PPSAA, Chapter 10, December 2012\n * (c) University of Melbourne */\n\ntypedef int data_t;     // we can change the type of data_t\n\ntypedef struct node node_t;\n\nstruct node {\n    data_t data;\n    node_t *next;\n};\n\ntypedef struct {\n    node_t *head;   // point to the front of the linked list\n    node_t *foot;   // the back\n} list_t;\n/* if we don't need to maintain the foot pointer, it's fine to do\n * typedef node_t *list_t;\n * then do list_t head = NULL; to create the empty linked list.\n */\n\n/* A linked list (using an array representation):\n * [head, head->next, head->next->next, ..., foot]\n *        ^^^^^ tail - all els except head. ^^^^^ */\n\nlist_t *make_empty_list(void);\nint is_empty_list(list_t *list);\nvoid free_list(list_t *list);\nlist_t *insert_at_head(list_t *list, data_t value);\nlist_t *insert_at_foot(list_t *list, data_t value);\ndata_t get_head(list_t *list);\nlist_t *get_tail(list_t *list);\n\n```\n```path:listops.c;eg:listops;norun\n/* list operations\n * Alistair Moffat, PPSAA, Chapter 10, December 2012\n * (c) University of Melbourne */\n\n#include \"listops.h\"\n#include <stdlib.h>\n#include <assert.h>\n\nlist_t *\nmake_empty_list(void) {\n    list_t *list = (list_t *) malloc(sizeof(*list));\n    assert(list != NULL);\n    list->head = list->foot = NULL;\n    return list;\n}\n\nint\nis_empty_list(list_t *list) {\n    assert(list != NULL);\n    return list->head == NULL;\n}\n\nvoid\nfree_list(list_t *list) {\n    assert(list != NULL);\n    // free the elements of the list\n    node_t *curr = list->head, *prev;\n    while (curr) {\n        prev = curr;\n        curr = curr->next;\n        free(prev);\n    }\n    // free the list itself\n    free(list);\n}\n\nlist_t *\ninsert_at_head(list_t *list, data_t value) {\n    node_t *new = (node_t *) malloc(sizeof(*new));\n    assert(list != NULL && new != NULL);\n    new->data = value;\n    new->next = list->head;\n    list->head = new;\n    if (list->foot == NULL) {\n        /* this is the first insertion into the list */\n        list->foot = new;\n    }\n    return list;\n}\n\nlist_t *\ninsert_at_foot(list_t *list, data_t value) {\n    node_t *new = (node_t *) malloc(sizeof(*new));\n    assert(list != NULL && new != NULL);\n    new->data = value;\n    new->next = NULL;\n    if (list->foot == NULL) {\n        /* this is the first insertion into the list */\n        list->head = new;\n        list->foot = new;\n    } else {\n        list->foot->next = new;\n        list->foot = new;\n    }\n    return list;\n}\n\ndata_t\nget_head(list_t *list) {\n    assert(list != NULL && list->head != NULL);\n    return list->head->data;\n}\n\nlist_t *\nget_tail(list_t *list) {\n    assert(list != NULL && list->head != NULL);\n    node_t *oldhead = list->head;\n    list->head = list->head->next;\n    if (list->head == NULL) {\n        /* the only list node just got deleted */\n        list->foot = NULL;\n    }\n    free(oldhead);\n    return list;\n}\n```\n```eg:listops\n/* Example program to illustrate linked list operations.\n * Alistair Moffat, PPSAA, Chapter 10, December 2012\n * (c) University of Melbourne */\n\n#include <stdio.h>\n#include <stdlib.h>\n\n#include \"listops.h\"\n\nint\nmain(int argc, char *argv[]) {\n    list_t *list = make_empty_list();\n    int i;\n    while (scanf(\"%d\", &i) == 1) {\n        list = insert_at_head(list, i);\n        list = insert_at_head(list, i+1);\n        list = insert_at_foot(list, i+2);\n    }\n    while (!is_empty_list(list)) {\n        i = get_head(list);\n        printf(\"%d \", i);\n        list = get_tail(list);\n    }\n    printf(\"\\n\");\n    free_list(list);\n    list = NULL;\n    return 0;\n}\n```\n```eg:last;path:Makefile;readonly;hidden;\nCC = clang\nCFLAGS = -Wall -Wno-unused-parameter -std=c11\n\nPROGRAM = program\nSOURCE_FILES = $(shell find . -type f -name '*.c')\nOBJECT_FILES = $(SOURCE_FILES:.c=.o)\n\n.PHONY: all build clean run\n\nall: build\n\nbuild: $(PROGRAM)\n\nclean:\n\trm -f $(PROGRAM) $(OBJECT_FILES)\n\nrun: build\n\t./$(PROGRAM)\n\n$(PROGRAM): $(OBJECT_FILES)\n\t$(CC) -o $@ $^ $(LDFLAGS)\n```\n",
            "rows": [
              {
                "left": "#markdown\n\nThe `listops.h` library has been included here, along with an example program.  Feel free to run it and inspect the code to see how it works.\n\n```path:listops.h;norun;eg:listops\n/* list operations\n * Alistair Moffat, PPSAA, Chapter 10, December 2012\n * (c) University of Melbourne */\n\ntypedef int data_t;     // we can change the type of data_t\n\ntypedef struct node node_t;\n\nstruct node {\n    data_t data;\n    node_t *next;\n};\n\ntypedef struct {\n    node_t *head;   // point to the front of the linked list\n    node_t *foot;   // the back\n} list_t;\n/* if we don't need to maintain the foot pointer, it's fine to do\n * typedef node_t *list_t;\n * then do list_t head = NULL; to create the empty linked list.\n */\n\n/* A linked list (using an array representation):\n * [head, head->next, head->next->next, ..., foot]\n *        ^^^^^ tail - all els except head. ^^^^^ */\n\nlist_t *make_empty_list(void);\nint is_empty_list(list_t *list);\nvoid free_list(list_t *list);\nlist_t *insert_at_head(list_t *list, data_t value);\nlist_t *insert_at_foot(list_t *list, data_t value);\ndata_t get_head(list_t *list);\nlist_t *get_tail(list_t *list);\n\n```\n```path:listops.c;eg:listops;norun\n/* list operations\n * Alistair Moffat, PPSAA, Chapter 10, December 2012\n * (c) University of Melbourne */\n\n#include \"listops.h\"\n#include <stdlib.h>\n#include <assert.h>\n\nlist_t *\nmake_empty_list(void) {\n    list_t *list = (list_t *) malloc(sizeof(*list));\n    assert(list != NULL);\n    list->head = list->foot = NULL;\n    return list;\n}\n\nint\nis_empty_list(list_t *list) {\n    assert(list != NULL);\n    return list->head == NULL;\n}\n\nvoid\nfree_list(list_t *list) {\n    assert(list != NULL);\n    // free the elements of the list\n    node_t *curr = list->head, *prev;\n    while (curr) {\n        prev = curr;\n        curr = curr->next;\n        free(prev);\n    }\n    // free the list itself\n    free(list);\n}\n\nlist_t *\ninsert_at_head(list_t *list, data_t value) {\n    node_t *new = (node_t *) malloc(sizeof(*new));\n    assert(list != NULL && new != NULL);\n    new->data = value;\n    new->next = list->head;\n    list->head = new;\n    if (list->foot == NULL) {\n        /* this is the first insertion into the list */\n        list->foot = new;\n    }\n    return list;\n}\n\nlist_t *\ninsert_at_foot(list_t *list, data_t value) {\n    node_t *new = (node_t *) malloc(sizeof(*new));\n    assert(list != NULL && new != NULL);\n    new->data = value;\n    new->next = NULL;\n    if (list->foot == NULL) {\n        /* this is the first insertion into the list */\n        list->head = new;\n        list->foot = new;\n    } else {\n        list->foot->next = new;\n        list->foot = new;\n    }\n    return list;\n}\n\ndata_t\nget_head(list_t *list) {\n    assert(list != NULL && list->head != NULL);\n    return list->head->data;\n}\n\nlist_t *\nget_tail(list_t *list) {\n    assert(list != NULL && list->head != NULL);\n    node_t *oldhead = list->head;\n    list->head = list->head->next;\n    if (list->head == NULL) {\n        /* the only list node just got deleted */\n        list->foot = NULL;\n    }\n    free(oldhead);\n    return list;\n}\n```\n```eg:listops\n/* Example program to illustrate linked list operations.\n * Alistair Moffat, PPSAA, Chapter 10, December 2012\n * (c) University of Melbourne */\n\n#include <stdio.h>\n#include <stdlib.h>\n\n#include \"listops.h\"\n\nint\nmain(int argc, char *argv[]) {\n    list_t *list = make_empty_list();\n    int i;\n    while (scanf(\"%d\", &i) == 1) {\n        list = insert_at_head(list, i);\n        list = insert_at_head(list, i+1);\n        list = insert_at_foot(list, i+2);\n    }\n    while (!is_empty_list(list)) {\n        i = get_head(list);\n        printf(\"%d \", i);\n        list = get_tail(list);\n    }\n    printf(\"\\n\");\n    free_list(list);\n    list = NULL;\n    return 0;\n}\n```\n```eg:last;path:Makefile;readonly;hidden;\nCC = clang\nCFLAGS = -Wall -Wno-unused-parameter -std=c11\n\nPROGRAM = program\nSOURCE_FILES = $(shell find . -type f -name '*.c')\nOBJECT_FILES = $(SOURCE_FILES:.c=.o)\n\n.PHONY: all build clean run\n\nall: build\n\nbuild: $(PROGRAM)\n\nclean:\n\trm -f $(PROGRAM) $(OBJECT_FILES)\n\nrun: build\n\t./$(PROGRAM)\n\n$(PROGRAM): $(OBJECT_FILES)\n\t$(CC) -o $@ $^ $(LDFLAGS)\n```\n"
              }
            ],
            "content_rendered": "<p>The <code data-lang=\"c\">listops.h</code> library has been included here, along with an example program.  Feel free to run it and inspect the code to see how it works.</p>\n<pre class=\"js-file-editor\" data-eg-id=\"listops\" data-path=\"listops.h\" data-runnable=\"false\"><code data-lang=\"c\">/* list operations\n * Alistair Moffat, PPSAA, Chapter 10, December 2012\n * (c) University of Melbourne */\n\ntypedef int data_t;     // we can change the type of data_t\n\ntypedef struct node node_t;\n\nstruct node {\n    data_t data;\n    node_t *next;\n};\n\ntypedef struct {\n    node_t *head;   // point to the front of the linked list\n    node_t *foot;   // the back\n} list_t;\n/* if we don't need to maintain the foot pointer, it's fine to do\n * typedef node_t *list_t;\n * then do list_t head = NULL; to create the empty linked list.\n */\n\n/* A linked list (using an array representation):\n * [head, head-&gt;next, head-&gt;next-&gt;next, ..., foot]\n *        ^^^^^ tail - all els except head. ^^^^^ */\n\nlist_t *make_empty_list(void);\nint is_empty_list(list_t *list);\nvoid free_list(list_t *list);\nlist_t *insert_at_head(list_t *list, data_t value);\nlist_t *insert_at_foot(list_t *list, data_t value);\ndata_t get_head(list_t *list);\nlist_t *get_tail(list_t *list);\n\n</code></pre>\n<pre class=\"js-file-editor\" data-eg-id=\"listops\" data-path=\"listops.c\" data-runnable=\"false\"><code data-lang=\"c\">/* list operations\n * Alistair Moffat, PPSAA, Chapter 10, December 2012\n * (c) University of Melbourne */\n\n#include &quot;listops.h&quot;\n#include &lt;stdlib.h&gt;\n#include &lt;assert.h&gt;\n\nlist_t *\nmake_empty_list(void) {\n    list_t *list = (list_t *) malloc(sizeof(*list));\n    assert(list != NULL);\n    list-&gt;head = list-&gt;foot = NULL;\n    return list;\n}\n\nint\nis_empty_list(list_t *list) {\n    assert(list != NULL);\n    return list-&gt;head == NULL;\n}\n\nvoid\nfree_list(list_t *list) {\n    assert(list != NULL);\n    // free the elements of the list\n    node_t *curr = list-&gt;head, *prev;\n    while (curr) {\n        prev = curr;\n        curr = curr-&gt;next;\n        free(prev);\n    }\n    // free the list itself\n    free(list);\n}\n\nlist_t *\ninsert_at_head(list_t *list, data_t value) {\n    node_t *new = (node_t *) malloc(sizeof(*new));\n    assert(list != NULL &amp;&amp; new != NULL);\n    new-&gt;data = value;\n    new-&gt;next = list-&gt;head;\n    list-&gt;head = new;\n    if (list-&gt;foot == NULL) {\n        /* this is the first insertion into the list */\n        list-&gt;foot = new;\n    }\n    return list;\n}\n\nlist_t *\ninsert_at_foot(list_t *list, data_t value) {\n    node_t *new = (node_t *) malloc(sizeof(*new));\n    assert(list != NULL &amp;&amp; new != NULL);\n    new-&gt;data = value;\n    new-&gt;next = NULL;\n    if (list-&gt;foot == NULL) {\n        /* this is the first insertion into the list */\n        list-&gt;head = new;\n        list-&gt;foot = new;\n    } else {\n        list-&gt;foot-&gt;next = new;\n        list-&gt;foot = new;\n    }\n    return list;\n}\n\ndata_t\nget_head(list_t *list) {\n    assert(list != NULL &amp;&amp; list-&gt;head != NULL);\n    return list-&gt;head-&gt;data;\n}\n\nlist_t *\nget_tail(list_t *list) {\n    assert(list != NULL &amp;&amp; list-&gt;head != NULL);\n    node_t *oldhead = list-&gt;head;\n    list-&gt;head = list-&gt;head-&gt;next;\n    if (list-&gt;head == NULL) {\n        /* the only list node just got deleted */\n        list-&gt;foot = NULL;\n    }\n    free(oldhead);\n    return list;\n}\n</code></pre>\n<pre class=\"js-editor\" data-eg-id=\"listops\"><code data-lang=\"c\">/* Example program to illustrate linked list operations.\n * Alistair Moffat, PPSAA, Chapter 10, December 2012\n * (c) University of Melbourne */\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\n#include &quot;listops.h&quot;\n\nint\nmain(int argc, char *argv[]) {\n    list_t *list = make_empty_list();\n    int i;\n    while (scanf(&quot;%d&quot;, &amp;i) == 1) {\n        list = insert_at_head(list, i);\n        list = insert_at_head(list, i+1);\n        list = insert_at_foot(list, i+2);\n    }\n    while (!is_empty_list(list)) {\n        i = get_head(list);\n        printf(&quot;%d &quot;, i);\n        list = get_tail(list);\n    }\n    printf(&quot;\\n&quot;);\n    free_list(list);\n    list = NULL;\n    return 0;\n}\n</code></pre>\n<pre class=\"js-file-editor\" data-eg-id=\"listops\" data-path=\"Makefile\" data-readonly=\"true\" style=\"display: none\"><code data-lang=\"c\">CC = clang\nCFLAGS = -Wall -Wno-unused-parameter -std=c11\n\nPROGRAM = program\nSOURCE_FILES = $(shell find . -type f -name '*.c')\nOBJECT_FILES = $(SOURCE_FILES:.c=.o)\n\n.PHONY: all build clean run\n\nall: build\n\nbuild: $(PROGRAM)\n\nclean:\n\trm -f $(PROGRAM) $(OBJECT_FILES)\n\nrun: build\n\t./$(PROGRAM)\n\n$(PROGRAM): $(OBJECT_FILES)\n\t$(CC) -o $@ $^ $(LDFLAGS)\n</code></pre>",
            "notes_rendered": ""
          },
          {
            "id": "cb5bbaf4-5d7b-466d-9c1f-4de105133636",
            "title": "Ex10.x2: Linked Lists",
            "type": 1,
            "layout": 0,
            "feedback_style": 0,
            "purpose": "",
            "problem_id": 15557,
            "authoring_notes": "",
            "tutor_notes": ""
          },
          {
            "id": "8b1e36aa-cda5-49a0-b8ef-0a15075f1938",
            "title": "Ex10.x3: Doubly Linked Lists",
            "type": 1,
            "layout": 0,
            "feedback_style": 0,
            "purpose": "",
            "problem_id": 15558,
            "authoring_notes": "",
            "tutor_notes": ""
          },
          {
            "id": "d456d7ae-6c76-44aa-940f-6fdff822b387",
            "title": "Stacks and Queues",
            "type": 0,
            "layout": 0,
            "feedback_style": 0,
            "purpose": "",
            "content_raw": "#markdown\n\n## Abstract Data Types (ADTs)\nStacks and queues are examples of Abstract Data Types.\n\nThat is, they specify a family of operations that operate on data, but do not specify a concrete implementation.  \n\nThey can be implemented with linked lists, arrays, among other concrete data structures.  But some data structures might provide better performance (time, space complexity) for operations we want.\n\n## Stacks\nA **stack** is an ADT in which the _most recently inserted item_ is returned next.  \n\nStacks are LIFO: Last In, First Out.  The last item in is the first item out.\n\nThink of a \"stack\" as a stack of plates.  You can only take a plate from the top of the stack (pop) and you can only add a plate to the top of the stack (push).  (Or, try using a stack of papers / homework.)\n\nThe main operations supported are:\n- `push(data)` -- adding data to the top of the stack\n- `data = pop()` -- removing from the top of the stack and return the data\n\nIn addition, we usually have operations for:\n- `make_empty_stack()` -- create a new empty stack\n- `free_stack()` -- free, destroy a stack and its elements\n- `is_empty()` -- is the stack empty?\n- `top()` -- get the top element of the stack, without removing it\n\n## Queues\nA **queue** is an ADT in which the _least recently inserted item_ is returned next.\n\nQueues are FIFO: First In, First Out.  The first item in is the first item out.  \n\nThink: When lining up at a restaurant, those in front of you are always served first, as they joined the queue before you.\n\nThe main operations supported are:\n- `enqueue(data)` -- adding data to the back of the queue\n- `data = dequeue()` -- removing from the front of the queue and return the data\n\nWe have the same extra operations as a stack.\n\n## Implementation using Linked Lists\nAs mentioned in PPSAA Chapter 10.2 and lec07 slide 30-31, an implementation for stacks and queues can be made using a linked list (using `listops.c`, `listops.h`).\n\nThe head of a linked list can be the top of the stack.  Then, the operations are:\n- `push`: `insert_at_head`\n- `pop`: `get_head`, then `get_tail`\n- `make_empty_stack`: `make_empty_list`\n- `free_stack`: `free_list`\n- `top`: `get_head`\n- `stack_is_empty`: `is_empty_list`\n\nFor a queue, we have the head of the linked list being the front of the queue, and the foot being the back of the queue.\n- `enqueue`: `insert_at_foot`\n- `dequeue`: `get_head`, then `get_tail`\n- etc\n\nThink: What is the time complexity of each of these operations?  Is that optimal?\n\n```\n#include \"listops.h\"\n\ntypedef list_t stack_t;\ntypedef list_t queue_t;\n\nstack_t *make_empty_stack() {\n    return make_empty_list();\n}\n\nvoid free_stack(stack_t *s) {\n    free_list(s);\n}\n\n// stack operations\n\nvoid push(stack_t *s, data_t value) {\n    insert_at_head(s, value);\n}\n\ndata_t pop(stack_t *s) {\n    data_t top = get_head(s);\n    get_tail(s);\n    return top;\n}\n\n// queue operations\n\ndata_t dequeue(queue_t *q, data_t value) {\n    insert_at_foot(q, value);\n}\n\ndata_t enqueue(queue_t *q) {\n    data_t top = get_head(q);\n    get_tail(q);\n    return top;\n}\n\n// left as an exercise to the reader\ndata_t top_stack(stack_t *);\nint stack_is_empty(stack_t *);\n\nqueue_t *new_stack();\nvoid free_stack(queue_t *);\ndata_t front_queue(queue_t *);\nint queue_is_empty(queue_t *);\n```\n\n## Implementation using Arrays\nIn Exercise 10.03, you can try implementing a stack with an array.\n",
            "rows": [
              {
                "left": "#markdown\n\n## Abstract Data Types (ADTs)\nStacks and queues are examples of Abstract Data Types.\n\nThat is, they specify a family of operations that operate on data, but do not specify a concrete implementation.  \n\nThey can be implemented with linked lists, arrays, among other concrete data structures.  But some data structures might provide better performance (time, space complexity) for operations we want.\n\n## Stacks\nA **stack** is an ADT in which the _most recently inserted item_ is returned next.  \n\nStacks are LIFO: Last In, First Out.  The last item in is the first item out.\n\nThink of a \"stack\" as a stack of plates.  You can only take a plate from the top of the stack (pop) and you can only add a plate to the top of the stack (push).  (Or, try using a stack of papers / homework.)\n\nThe main operations supported are:\n- `push(data)` -- adding data to the top of the stack\n- `data = pop()` -- removing from the top of the stack and return the data\n\nIn addition, we usually have operations for:\n- `make_empty_stack()` -- create a new empty stack\n- `free_stack()` -- free, destroy a stack and its elements\n- `is_empty()` -- is the stack empty?\n- `top()` -- get the top element of the stack, without removing it\n\n## Queues\nA **queue** is an ADT in which the _least recently inserted item_ is returned next.\n\nQueues are FIFO: First In, First Out.  The first item in is the first item out.  \n\nThink: When lining up at a restaurant, those in front of you are always served first, as they joined the queue before you.\n\nThe main operations supported are:\n- `enqueue(data)` -- adding data to the back of the queue\n- `data = dequeue()` -- removing from the front of the queue and return the data\n\nWe have the same extra operations as a stack.\n\n## Implementation using Linked Lists\nAs mentioned in PPSAA Chapter 10.2 and lec07 slide 30-31, an implementation for stacks and queues can be made using a linked list (using `listops.c`, `listops.h`).\n\nThe head of a linked list can be the top of the stack.  Then, the operations are:\n- `push`: `insert_at_head`\n- `pop`: `get_head`, then `get_tail`\n- `make_empty_stack`: `make_empty_list`\n- `free_stack`: `free_list`\n- `top`: `get_head`\n- `stack_is_empty`: `is_empty_list`\n\nFor a queue, we have the head of the linked list being the front of the queue, and the foot being the back of the queue.\n- `enqueue`: `insert_at_foot`\n- `dequeue`: `get_head`, then `get_tail`\n- etc\n\nThink: What is the time complexity of each of these operations?  Is that optimal?\n\n```\n#include \"listops.h\"\n\ntypedef list_t stack_t;\ntypedef list_t queue_t;\n\nstack_t *make_empty_stack() {\n    return make_empty_list();\n}\n\nvoid free_stack(stack_t *s) {\n    free_list(s);\n}\n\n// stack operations\n\nvoid push(stack_t *s, data_t value) {\n    insert_at_head(s, value);\n}\n\ndata_t pop(stack_t *s) {\n    data_t top = get_head(s);\n    get_tail(s);\n    return top;\n}\n\n// queue operations\n\ndata_t dequeue(queue_t *q, data_t value) {\n    insert_at_foot(q, value);\n}\n\ndata_t enqueue(queue_t *q) {\n    data_t top = get_head(q);\n    get_tail(q);\n    return top;\n}\n\n// left as an exercise to the reader\ndata_t top_stack(stack_t *);\nint stack_is_empty(stack_t *);\n\nqueue_t *new_stack();\nvoid free_stack(queue_t *);\ndata_t front_queue(queue_t *);\nint queue_is_empty(queue_t *);\n```\n\n## Implementation using Arrays\nIn Exercise 10.03, you can try implementing a stack with an array.\n"
              }
            ],
            "content_rendered": "<h2>Abstract Data Types (ADTs)</h2>\n<p>Stacks and queues are examples of Abstract Data Types.</p>\n<p>That is, they specify a family of operations that operate on data, but do not specify a concrete implementation.</p>\n<p>They can be implemented with linked lists, arrays, among other concrete data structures.  But some data structures might provide better performance (time, space complexity) for operations we want.</p>\n<h2>Stacks</h2>\n<p>A <strong>stack</strong> is an ADT in which the <em>most recently inserted item</em> is returned next.</p>\n<p>Stacks are LIFO: Last In, First Out.  The last item in is the first item out.</p>\n<p>Think of a &quot;stack&quot; as a stack of plates.  You can only take a plate from the top of the stack (pop) and you can only add a plate to the top of the stack (push).  (Or, try using a stack of papers / homework.)</p>\n<p>The main operations supported are:</p>\n<ul>\n<li><code data-lang=\"c\">push(data)</code> &ndash; adding data to the top of the stack</li>\n<li><code data-lang=\"c\">data = pop()</code> &ndash; removing from the top of the stack and return the data</li>\n</ul>\n<p>In addition, we usually have operations for:</p>\n<ul>\n<li><code data-lang=\"c\">make_empty_stack()</code> &ndash; create a new empty stack</li>\n<li><code data-lang=\"c\">free_stack()</code> &ndash; free, destroy a stack and its elements</li>\n<li><code data-lang=\"c\">is_empty()</code> &ndash; is the stack empty?</li>\n<li><code data-lang=\"c\">top()</code> &ndash; get the top element of the stack, without removing it</li>\n</ul>\n<h2>Queues</h2>\n<p>A <strong>queue</strong> is an ADT in which the <em>least recently inserted item</em> is returned next.</p>\n<p>Queues are FIFO: First In, First Out.  The first item in is the first item out.</p>\n<p>Think: When lining up at a restaurant, those in front of you are always served first, as they joined the queue before you.</p>\n<p>The main operations supported are:</p>\n<ul>\n<li><code data-lang=\"c\">enqueue(data)</code> &ndash; adding data to the back of the queue</li>\n<li><code data-lang=\"c\">data = dequeue()</code> &ndash; removing from the front of the queue and return the data</li>\n</ul>\n<p>We have the same extra operations as a stack.</p>\n<h2>Implementation using Linked Lists</h2>\n<p>As mentioned in PPSAA Chapter 10.2 and lec07 slide 30-31, an implementation for stacks and queues can be made using a linked list (using <code data-lang=\"c\">listops.c</code>, <code data-lang=\"c\">listops.h</code>).</p>\n<p>The head of a linked list can be the top of the stack.  Then, the operations are:</p>\n<ul>\n<li><code data-lang=\"c\">push</code>: <code data-lang=\"c\">insert_at_head</code></li>\n<li><code data-lang=\"c\">pop</code>: <code data-lang=\"c\">get_head</code>, then <code data-lang=\"c\">get_tail</code></li>\n<li><code data-lang=\"c\">make_empty_stack</code>: <code data-lang=\"c\">make_empty_list</code></li>\n<li><code data-lang=\"c\">free_stack</code>: <code data-lang=\"c\">free_list</code></li>\n<li><code data-lang=\"c\">top</code>: <code data-lang=\"c\">get_head</code></li>\n<li><code data-lang=\"c\">stack_is_empty</code>: <code data-lang=\"c\">is_empty_list</code></li>\n</ul>\n<p>For a queue, we have the head of the linked list being the front of the queue, and the foot being the back of the queue.</p>\n<ul>\n<li><code data-lang=\"c\">enqueue</code>: <code data-lang=\"c\">insert_at_foot</code></li>\n<li><code data-lang=\"c\">dequeue</code>: <code data-lang=\"c\">get_head</code>, then <code data-lang=\"c\">get_tail</code></li>\n<li>etc</li>\n</ul>\n<p>Think: What is the time complexity of each of these operations?  Is that optimal?</p>\n<pre class=\"js-editor\" data-eg-id=\"unimelb-comp10002-2022-s1-chapter10-0-7-0\"><code data-lang=\"c\">#include &quot;listops.h&quot;\n\ntypedef list_t stack_t;\ntypedef list_t queue_t;\n\nstack_t *make_empty_stack() {\n    return make_empty_list();\n}\n\nvoid free_stack(stack_t *s) {\n    free_list(s);\n}\n\n// stack operations\n\nvoid push(stack_t *s, data_t value) {\n    insert_at_head(s, value);\n}\n\ndata_t pop(stack_t *s) {\n    data_t top = get_head(s);\n    get_tail(s);\n    return top;\n}\n\n// queue operations\n\ndata_t dequeue(queue_t *q, data_t value) {\n    insert_at_foot(q, value);\n}\n\ndata_t enqueue(queue_t *q) {\n    data_t top = get_head(q);\n    get_tail(q);\n    return top;\n}\n\n// left as an exercise to the reader\ndata_t top_stack(stack_t *);\nint stack_is_empty(stack_t *);\n\nqueue_t *new_stack();\nvoid free_stack(queue_t *);\ndata_t front_queue(queue_t *);\nint queue_is_empty(queue_t *);\n</code></pre>\n<h2>Implementation using Arrays</h2>\n<p>In Exercise 10.03, you can try implementing a stack with an array.</p>",
            "notes_rendered": ""
          },
          {
            "id": "f03d886b-06a5-4ce9-81c3-4224c049076d",
            "title": "Ex10.03: Stack and queue using array",
            "type": 1,
            "layout": 0,
            "feedback_style": 0,
            "purpose": "",
            "problem_id": 15559,
            "authoring_notes": "",
            "tutor_notes": ""
          },
          {
            "id": "587dd2a6-dfa9-4061-b1c4-4b9dcc06a996",
            "title": "Function pointers (Figures 10.9)",
            "type": 0,
            "layout": 0,
            "feedback_style": 0,
            "purpose": "",
            "content_raw": "#markdown\nIn the program below, `F` is a function pointer, which we can assign to any function that takes one `double` argument and returns one `double` argument.  The `sqrt`, `sin` and `log` functions fit that description (from `<math.h>`).\n\nIn C, `*F`, `F`, `***F`, and `&F` are the same thing for function pointers, so we can just treat \"function pointers\" just as regular functions.  See page 179-180 for more details.\n```\n/* Show the declaration and use of function pointers.\n*/\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\nint\nmain(int argc, char *argv[]) {\n\tdouble (*F)(double), x=2.0;\n\tF = sqrt;\n\tprintf(\"x=%.4f, F(x)=%.4f\\n\", x, F(x));\n\tF = sin;\n\tprintf(\"x=%.4f, F(x)=%.4f\\n\", x, F(x));\n\tF = log;\n\tprintf(\"x=%.4f, F(x)=%.4f\\n\", x, F(x));\n\tprintf(\"x=%.4f, (*F)(x)=%.4f\\n\", x, (*F)(x));\n\treturn 0;\n}\n```\n```eg:last;path:Makefile;readonly;hidden;\nCC = clang\nCFLAGS = -Wall -Wno-unused-parameter -std=c11\n\nPROGRAM = program\nSOURCE_FILES = $(shell find . -type f -name '*.c')\nOBJECT_FILES = $(SOURCE_FILES:.c=.o)\n\n.PHONY: all build clean run\n\nall: build\n\nbuild: $(PROGRAM)\n\nclean:\n\trm -f $(PROGRAM) $(OBJECT_FILES)\n\nrun: build\n\t./$(PROGRAM)\n\n$(PROGRAM): $(OBJECT_FILES)\n\t$(CC) -o $@ $^ $(LDFLAGS)\n```\n\n\n",
            "rows": [
              {
                "left": "#markdown\nIn the program below, `F` is a function pointer, which we can assign to any function that takes one `double` argument and returns one `double` argument.  The `sqrt`, `sin` and `log` functions fit that description (from `<math.h>`).\n\nIn C, `*F`, `F`, `***F`, and `&F` are the same thing for function pointers, so we can just treat \"function pointers\" just as regular functions.  See page 179-180 for more details.\n```\n/* Show the declaration and use of function pointers.\n*/\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\nint\nmain(int argc, char *argv[]) {\n\tdouble (*F)(double), x=2.0;\n\tF = sqrt;\n\tprintf(\"x=%.4f, F(x)=%.4f\\n\", x, F(x));\n\tF = sin;\n\tprintf(\"x=%.4f, F(x)=%.4f\\n\", x, F(x));\n\tF = log;\n\tprintf(\"x=%.4f, F(x)=%.4f\\n\", x, F(x));\n\tprintf(\"x=%.4f, (*F)(x)=%.4f\\n\", x, (*F)(x));\n\treturn 0;\n}\n```\n```eg:last;path:Makefile;readonly;hidden;\nCC = clang\nCFLAGS = -Wall -Wno-unused-parameter -std=c11\n\nPROGRAM = program\nSOURCE_FILES = $(shell find . -type f -name '*.c')\nOBJECT_FILES = $(SOURCE_FILES:.c=.o)\n\n.PHONY: all build clean run\n\nall: build\n\nbuild: $(PROGRAM)\n\nclean:\n\trm -f $(PROGRAM) $(OBJECT_FILES)\n\nrun: build\n\t./$(PROGRAM)\n\n$(PROGRAM): $(OBJECT_FILES)\n\t$(CC) -o $@ $^ $(LDFLAGS)\n```\n\n\n"
              }
            ],
            "content_rendered": "<p>In the program below, <code data-lang=\"c\">F</code> is a function pointer, which we can assign to any function that takes one <code data-lang=\"c\">double</code> argument and returns one <code data-lang=\"c\">double</code> argument.  The <code data-lang=\"c\">sqrt</code>, <code data-lang=\"c\">sin</code> and <code data-lang=\"c\">log</code> functions fit that description (from <code data-lang=\"c\">&lt;math.h&gt;</code>).</p>\n<p>In C, <code data-lang=\"c\">*F</code>, <code data-lang=\"c\">F</code>, <code data-lang=\"c\">***F</code>, and <code data-lang=\"c\">&amp;F</code> are the same thing for function pointers, so we can just treat &quot;function pointers&quot; just as regular functions.  See page 179-180 for more details.</p>\n<pre class=\"js-editor\" data-eg-id=\"unimelb-comp10002-2022-s1-chapter10-0-9-0\"><code data-lang=\"c\">/* Show the declaration and use of function pointers.\n*/\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;math.h&gt;\n\nint\nmain(int argc, char *argv[]) {\n\tdouble (*F)(double), x=2.0;\n\tF = sqrt;\n\tprintf(&quot;x=%.4f, F(x)=%.4f\\n&quot;, x, F(x));\n\tF = sin;\n\tprintf(&quot;x=%.4f, F(x)=%.4f\\n&quot;, x, F(x));\n\tF = log;\n\tprintf(&quot;x=%.4f, F(x)=%.4f\\n&quot;, x, F(x));\n\tprintf(&quot;x=%.4f, (*F)(x)=%.4f\\n&quot;, x, (*F)(x));\n\treturn 0;\n}\n</code></pre>\n<pre class=\"js-file-editor\" data-eg-id=\"unimelb-comp10002-2022-s1-chapter10-0-9-0\" data-path=\"Makefile\" data-readonly=\"true\" style=\"display: none\"><code data-lang=\"c\">CC = clang\nCFLAGS = -Wall -Wno-unused-parameter -std=c11\n\nPROGRAM = program\nSOURCE_FILES = $(shell find . -type f -name '*.c')\nOBJECT_FILES = $(SOURCE_FILES:.c=.o)\n\n.PHONY: all build clean run\n\nall: build\n\nbuild: $(PROGRAM)\n\nclean:\n\trm -f $(PROGRAM) $(OBJECT_FILES)\n\nrun: build\n\t./$(PROGRAM)\n\n$(PROGRAM): $(OBJECT_FILES)\n\t$(CC) -o $@ $^ $(LDFLAGS)\n</code></pre>",
            "notes_rendered": ""
          },
          {
            "id": "20e07e03-6fc3-4f12-a91b-ddccd51bcc99",
            "title": "Polymorphic functions (Figures 10.10-11)",
            "type": 0,
            "layout": 2,
            "feedback_style": 0,
            "purpose": "",
            "content_raw": "#markdown\nSee page 180-182 of PPSAA for a run-through of this program.\n\nNote that `sizeof(X)/sizeof(*X)` only works for arrays declared within that scope.  Also, you can edit the code below in that box (but it won't save if you navigate away).\n```\n/* Show the use of function pointers.\n * PPSAA Figures 10.10 and 10.11, Alistair Moffat\n*/\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint is_sorted(void *A, size_t nelem, size_t size, \n\t\t\tint (*cmp)(void*,void*));\n\nint\ndouble_ascending(void *v1, void *v2) {\n\tdouble *d1=v1, *d2=v2;\n\tif (*d1<*d2) return -1;\n\tif (*d1>*d2) return +1;\n\treturn 0;\n}\n\nint\ndouble_descending(void *v1, void *v2) {\n\tdouble *d1=v1, *d2=v2;\n\treturn *d2 - *d1;\n}\n\nint\nstring_ascending(void *v1, void *v2) {\n\tchar **s1=v1, **s2=v2;\n\treturn strcmp(*s1,*s2);\n}\n\nint\nstring_descending(void *v1, void *v2) {\n\tchar **s1=v1, **s2=v2;\n\treturn -strcmp(*s1,*s2);\n}\n\nint\nmain(int argc, char *argv[]) {\n\tdouble X[] = {1.87, 3.43, 7.64, 7.68, 8.16, 9.86};\n\tchar *S[] = {\"wombat\", \"wallaby\", \"quoll\", \"quokka\",\n\t\t\"koala\", \"kangaroo\", \"goanna\", \"bilby\"};\n\tif (is_sorted(X, sizeof(X)/sizeof(*X), sizeof(*X),\n\t\t\tdouble_ascending)) {\n\t\tprintf(\"Array X is ascending\\n\");\n\t}\n\tif (is_sorted(S, sizeof(S)/sizeof(*S), sizeof(*S),\n\t\t\tstring_descending)) {\n\t\tprintf(\"Array S is descending\\n\");\n\t}\n\treturn 0;\n}\n\nint\nis_sorted(void *A, size_t nelem, size_t size, \n\t\tint (*cmp)(void*,void*)) {\n\tchar *Ap=(char *)A;\n\twhile (nelem>1) {\n\t\tif (cmp(Ap, Ap+size) > 0) {\n\t\t\t/* these two are out of order */\n\t\t\treturn 0;\n\t\t}\n\t\tAp += size;\n\t\tnelem -= 1;\n\t}\n\t/* all elements have been checked, and are ok */\n\treturn 1;\n}\n```\n```eg:last;path:Makefile;readonly;hidden;\nCC = clang\nCFLAGS = -Wall -Wno-unused-parameter -std=c11\n\nPROGRAM = program\nSOURCE_FILES = $(shell find . -type f -name '*.c')\nOBJECT_FILES = $(SOURCE_FILES:.c=.o)\n\n.PHONY: all build clean run\n\nall: build\n\nbuild: $(PROGRAM)\n\nclean:\n\trm -f $(PROGRAM) $(OBJECT_FILES)\n\nrun: build\n\t./$(PROGRAM)\n\n$(PROGRAM): $(OBJECT_FILES)\n\t$(CC) -o $@ $^ $(LDFLAGS)\n```\n\n",
            "rows": [
              {
                "left": "#markdown\nSee page 180-182 of PPSAA for a run-through of this program.\n\nNote that `sizeof(X)/sizeof(*X)` only works for arrays declared within that scope.  Also, you can edit the code below in that box (but it won't save if you navigate away).\n```\n/* Show the use of function pointers.\n * PPSAA Figures 10.10 and 10.11, Alistair Moffat\n*/\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint is_sorted(void *A, size_t nelem, size_t size, \n\t\t\tint (*cmp)(void*,void*));\n\nint\ndouble_ascending(void *v1, void *v2) {\n\tdouble *d1=v1, *d2=v2;\n\tif (*d1<*d2) return -1;\n\tif (*d1>*d2) return +1;\n\treturn 0;\n}\n\nint\ndouble_descending(void *v1, void *v2) {\n\tdouble *d1=v1, *d2=v2;\n\treturn *d2 - *d1;\n}\n\nint\nstring_ascending(void *v1, void *v2) {\n\tchar **s1=v1, **s2=v2;\n\treturn strcmp(*s1,*s2);\n}\n\nint\nstring_descending(void *v1, void *v2) {\n\tchar **s1=v1, **s2=v2;\n\treturn -strcmp(*s1,*s2);\n}\n\nint\nmain(int argc, char *argv[]) {\n\tdouble X[] = {1.87, 3.43, 7.64, 7.68, 8.16, 9.86};\n\tchar *S[] = {\"wombat\", \"wallaby\", \"quoll\", \"quokka\",\n\t\t\"koala\", \"kangaroo\", \"goanna\", \"bilby\"};\n\tif (is_sorted(X, sizeof(X)/sizeof(*X), sizeof(*X),\n\t\t\tdouble_ascending)) {\n\t\tprintf(\"Array X is ascending\\n\");\n\t}\n\tif (is_sorted(S, sizeof(S)/sizeof(*S), sizeof(*S),\n\t\t\tstring_descending)) {\n\t\tprintf(\"Array S is descending\\n\");\n\t}\n\treturn 0;\n}\n\nint\nis_sorted(void *A, size_t nelem, size_t size, \n\t\tint (*cmp)(void*,void*)) {\n\tchar *Ap=(char *)A;\n\twhile (nelem>1) {\n\t\tif (cmp(Ap, Ap+size) > 0) {\n\t\t\t/* these two are out of order */\n\t\t\treturn 0;\n\t\t}\n\t\tAp += size;\n\t\tnelem -= 1;\n\t}\n\t/* all elements have been checked, and are ok */\n\treturn 1;\n}\n```\n```eg:last;path:Makefile;readonly;hidden;\nCC = clang\nCFLAGS = -Wall -Wno-unused-parameter -std=c11\n\nPROGRAM = program\nSOURCE_FILES = $(shell find . -type f -name '*.c')\nOBJECT_FILES = $(SOURCE_FILES:.c=.o)\n\n.PHONY: all build clean run\n\nall: build\n\nbuild: $(PROGRAM)\n\nclean:\n\trm -f $(PROGRAM) $(OBJECT_FILES)\n\nrun: build\n\t./$(PROGRAM)\n\n$(PROGRAM): $(OBJECT_FILES)\n\t$(CC) -o $@ $^ $(LDFLAGS)\n```\n\n"
              }
            ],
            "content_rendered": "<p>See page 180-182 of PPSAA for a run-through of this program.</p>\n<p>Note that <code data-lang=\"c\">sizeof(X)/sizeof(*X)</code> only works for arrays declared within that scope.  Also, you can edit the code below in that box (but it won't save if you navigate away).</p>\n<pre class=\"js-editor\" data-eg-id=\"unimelb-comp10002-2022-s1-chapter10-0-10-0\"><code data-lang=\"c\">/* Show the use of function pointers.\n * PPSAA Figures 10.10 and 10.11, Alistair Moffat\n*/\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n\nint is_sorted(void *A, size_t nelem, size_t size, \n\t\t\tint (*cmp)(void*,void*));\n\nint\ndouble_ascending(void *v1, void *v2) {\n\tdouble *d1=v1, *d2=v2;\n\tif (*d1&lt;*d2) return -1;\n\tif (*d1&gt;*d2) return +1;\n\treturn 0;\n}\n\nint\ndouble_descending(void *v1, void *v2) {\n\tdouble *d1=v1, *d2=v2;\n\treturn *d2 - *d1;\n}\n\nint\nstring_ascending(void *v1, void *v2) {\n\tchar **s1=v1, **s2=v2;\n\treturn strcmp(*s1,*s2);\n}\n\nint\nstring_descending(void *v1, void *v2) {\n\tchar **s1=v1, **s2=v2;\n\treturn -strcmp(*s1,*s2);\n}\n\nint\nmain(int argc, char *argv[]) {\n\tdouble X[] = {1.87, 3.43, 7.64, 7.68, 8.16, 9.86};\n\tchar *S[] = {&quot;wombat&quot;, &quot;wallaby&quot;, &quot;quoll&quot;, &quot;quokka&quot;,\n\t\t&quot;koala&quot;, &quot;kangaroo&quot;, &quot;goanna&quot;, &quot;bilby&quot;};\n\tif (is_sorted(X, sizeof(X)/sizeof(*X), sizeof(*X),\n\t\t\tdouble_ascending)) {\n\t\tprintf(&quot;Array X is ascending\\n&quot;);\n\t}\n\tif (is_sorted(S, sizeof(S)/sizeof(*S), sizeof(*S),\n\t\t\tstring_descending)) {\n\t\tprintf(&quot;Array S is descending\\n&quot;);\n\t}\n\treturn 0;\n}\n\nint\nis_sorted(void *A, size_t nelem, size_t size, \n\t\tint (*cmp)(void*,void*)) {\n\tchar *Ap=(char *)A;\n\twhile (nelem&gt;1) {\n\t\tif (cmp(Ap, Ap+size) &gt; 0) {\n\t\t\t/* these two are out of order */\n\t\t\treturn 0;\n\t\t}\n\t\tAp += size;\n\t\tnelem -= 1;\n\t}\n\t/* all elements have been checked, and are ok */\n\treturn 1;\n}\n</code></pre>\n<pre class=\"js-file-editor\" data-eg-id=\"unimelb-comp10002-2022-s1-chapter10-0-10-0\" data-path=\"Makefile\" data-readonly=\"true\" style=\"display: none\"><code data-lang=\"c\">CC = clang\nCFLAGS = -Wall -Wno-unused-parameter -std=c11\n\nPROGRAM = program\nSOURCE_FILES = $(shell find . -type f -name '*.c')\nOBJECT_FILES = $(SOURCE_FILES:.c=.o)\n\n.PHONY: all build clean run\n\nall: build\n\nbuild: $(PROGRAM)\n\nclean:\n\trm -f $(PROGRAM) $(OBJECT_FILES)\n\nrun: build\n\t./$(PROGRAM)\n\n$(PROGRAM): $(OBJECT_FILES)\n\t$(CC) -o $@ $^ $(LDFLAGS)\n</code></pre>",
            "notes_rendered": ""
          },
          {
            "id": "bff2bbd3-80e9-4e70-a7bc-299da472db6b",
            "title": "qsort (Figure 10.12)",
            "type": 0,
            "layout": 2,
            "feedback_style": 0,
            "purpose": "",
            "content_raw": "#markdown\n\n`<stdlib.h>` includes a polymorphic `qsort`.  See its prototype below (from the Unix Manual):\n```norun;readonly\nvoid qsort(void *base, size_t nmemb, size_t size,\n           int (*compar)(const void *, const void *));\n```\n\nAll we have to do to use it, is provide an array (`base`), the number of elements in the array (`nmemb`), the size of each element (`size`, usually by calling `sizeof(A[0])`), and a comparator `compar`.\n\nAny comparator should distinguish the ordering between two elements `v1` and `v2`.  If `v1 < v2` (less than), return a negative number; if `v1 > v2` (greater than), return a positive number; if `v1 == v2` (equal), return 0.\n\n```\n/* Show the use of the library qsort function.\n * Alistair Moffat, PPSAA, Chapter 10, December 2012\n * (c) University of Melbourne */\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint\nstring_ascending(const void *v1, const void *v2) {\n\treturn strcmp(*(char**)v1,*(char**)v2);\n}\n\nint\nmain(int argc, char *argv[]) {\n\tchar *S[] = {\"koala\", \"kangaroo\", \"quoll\", \"quokka\",\n\t\t\"wombat\", \"goanna\", \"wallaby\", \"bilby\"};\n\tint n = sizeof(S) / sizeof(*S);\n\tqsort(S, n, sizeof(*S), string_ascending);\n\tfor (int i=0; i<n; i++) {\n\t\tprintf(\"%s\\n\", S[i]);\n\t}\n\treturn 0;\n}\n\n\n```\n```eg:last;path:Makefile;readonly;hidden;\nCC = clang\nCFLAGS = -Wall -Wno-unused-parameter -std=c11\n\nPROGRAM = program\nSOURCE_FILES = $(shell find . -type f -name '*.c')\nOBJECT_FILES = $(SOURCE_FILES:.c=.o)\n\n.PHONY: all build clean run\n\nall: build\n\nbuild: $(PROGRAM)\n\nclean:\n\trm -f $(PROGRAM) $(OBJECT_FILES)\n\nrun: build\n\t./$(PROGRAM)\n\n$(PROGRAM): $(OBJECT_FILES)\n\t$(CC) -o $@ $^ $(LDFLAGS)\n```\n\n\nArguments are tagged as `const` if they do not change at all while the function is executing, allowing the compiler to handle them efficiently.  `qsort` includes `const` arguments, so the calling sequence must likewise specify a comparison function that takes `const` arguments if compiler warning messages are to be avoided. (PPSAA 10.5)\n\n\nBe careful, the `sizeof(S) / sizeof(*S)` trick (recall `*S` is simply `S[0]`) will not work if the array `S` is created in a different scope.  For example, if we create `S` in `main` and pass `S` to another function, `S` will just be a pointer, not an array, so `sizeof(S) = sizeof(void *) =` 4 bytes (32-bit) or 8 bytes (64-bit).\n",
            "rows": [
              {
                "left": "#markdown\n\n`<stdlib.h>` includes a polymorphic `qsort`.  See its prototype below (from the Unix Manual):\n```norun;readonly\nvoid qsort(void *base, size_t nmemb, size_t size,\n           int (*compar)(const void *, const void *));\n```\n\nAll we have to do to use it, is provide an array (`base`), the number of elements in the array (`nmemb`), the size of each element (`size`, usually by calling `sizeof(A[0])`), and a comparator `compar`.\n\nAny comparator should distinguish the ordering between two elements `v1` and `v2`.  If `v1 < v2` (less than), return a negative number; if `v1 > v2` (greater than), return a positive number; if `v1 == v2` (equal), return 0.\n\n```\n/* Show the use of the library qsort function.\n * Alistair Moffat, PPSAA, Chapter 10, December 2012\n * (c) University of Melbourne */\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint\nstring_ascending(const void *v1, const void *v2) {\n\treturn strcmp(*(char**)v1,*(char**)v2);\n}\n\nint\nmain(int argc, char *argv[]) {\n\tchar *S[] = {\"koala\", \"kangaroo\", \"quoll\", \"quokka\",\n\t\t\"wombat\", \"goanna\", \"wallaby\", \"bilby\"};\n\tint n = sizeof(S) / sizeof(*S);\n\tqsort(S, n, sizeof(*S), string_ascending);\n\tfor (int i=0; i<n; i++) {\n\t\tprintf(\"%s\\n\", S[i]);\n\t}\n\treturn 0;\n}\n\n\n```\n```eg:last;path:Makefile;readonly;hidden;\nCC = clang\nCFLAGS = -Wall -Wno-unused-parameter -std=c11\n\nPROGRAM = program\nSOURCE_FILES = $(shell find . -type f -name '*.c')\nOBJECT_FILES = $(SOURCE_FILES:.c=.o)\n\n.PHONY: all build clean run\n\nall: build\n\nbuild: $(PROGRAM)\n\nclean:\n\trm -f $(PROGRAM) $(OBJECT_FILES)\n\nrun: build\n\t./$(PROGRAM)\n\n$(PROGRAM): $(OBJECT_FILES)\n\t$(CC) -o $@ $^ $(LDFLAGS)\n```\n\n\nArguments are tagged as `const` if they do not change at all while the function is executing, allowing the compiler to handle them efficiently.  `qsort` includes `const` arguments, so the calling sequence must likewise specify a comparison function that takes `const` arguments if compiler warning messages are to be avoided. (PPSAA 10.5)\n\n\nBe careful, the `sizeof(S) / sizeof(*S)` trick (recall `*S` is simply `S[0]`) will not work if the array `S` is created in a different scope.  For example, if we create `S` in `main` and pass `S` to another function, `S` will just be a pointer, not an array, so `sizeof(S) = sizeof(void *) =` 4 bytes (32-bit) or 8 bytes (64-bit).\n"
              }
            ],
            "content_rendered": "<p><code data-lang=\"c\">&lt;stdlib.h&gt;</code> includes a polymorphic <code data-lang=\"c\">qsort</code>.  See its prototype below (from the Unix Manual):</p>\n<pre class=\"js-editor\" data-eg-id=\"unimelb-comp10002-2022-s1-chapter10-0-11-0\" data-readonly=\"true\" data-runnable=\"false\"><code data-lang=\"c\">void qsort(void *base, size_t nmemb, size_t size,\n           int (*compar)(const void *, const void *));\n</code></pre>\n<p>All we have to do to use it, is provide an array (<code data-lang=\"c\">base</code>), the number of elements in the array (<code data-lang=\"c\">nmemb</code>), the size of each element (<code data-lang=\"c\">size</code>, usually by calling <code data-lang=\"c\">sizeof(A[0])</code>), and a comparator <code data-lang=\"c\">compar</code>.</p>\n<p>Any comparator should distinguish the ordering between two elements <code data-lang=\"c\">v1</code> and <code data-lang=\"c\">v2</code>.  If <code data-lang=\"c\">v1 &lt; v2</code> (less than), return a negative number; if <code data-lang=\"c\">v1 &gt; v2</code> (greater than), return a positive number; if <code data-lang=\"c\">v1 == v2</code> (equal), return 0.</p>\n<pre class=\"js-editor\" data-eg-id=\"unimelb-comp10002-2022-s1-chapter10-0-11-1\"><code data-lang=\"c\">/* Show the use of the library qsort function.\n * Alistair Moffat, PPSAA, Chapter 10, December 2012\n * (c) University of Melbourne */\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n\nint\nstring_ascending(const void *v1, const void *v2) {\n\treturn strcmp(*(char**)v1,*(char**)v2);\n}\n\nint\nmain(int argc, char *argv[]) {\n\tchar *S[] = {&quot;koala&quot;, &quot;kangaroo&quot;, &quot;quoll&quot;, &quot;quokka&quot;,\n\t\t&quot;wombat&quot;, &quot;goanna&quot;, &quot;wallaby&quot;, &quot;bilby&quot;};\n\tint n = sizeof(S) / sizeof(*S);\n\tqsort(S, n, sizeof(*S), string_ascending);\n\tfor (int i=0; i&lt;n; i++) {\n\t\tprintf(&quot;%s\\n&quot;, S[i]);\n\t}\n\treturn 0;\n}\n\n\n</code></pre>\n<pre class=\"js-file-editor\" data-eg-id=\"unimelb-comp10002-2022-s1-chapter10-0-11-1\" data-path=\"Makefile\" data-readonly=\"true\" style=\"display: none\"><code data-lang=\"c\">CC = clang\nCFLAGS = -Wall -Wno-unused-parameter -std=c11\n\nPROGRAM = program\nSOURCE_FILES = $(shell find . -type f -name '*.c')\nOBJECT_FILES = $(SOURCE_FILES:.c=.o)\n\n.PHONY: all build clean run\n\nall: build\n\nbuild: $(PROGRAM)\n\nclean:\n\trm -f $(PROGRAM) $(OBJECT_FILES)\n\nrun: build\n\t./$(PROGRAM)\n\n$(PROGRAM): $(OBJECT_FILES)\n\t$(CC) -o $@ $^ $(LDFLAGS)\n</code></pre>\n<p>Arguments are tagged as <code data-lang=\"c\">const</code> if they do not change at all while the function is executing, allowing the compiler to handle them efficiently.  <code data-lang=\"c\">qsort</code> includes <code data-lang=\"c\">const</code> arguments, so the calling sequence must likewise specify a comparison function that takes <code data-lang=\"c\">const</code> arguments if compiler warning messages are to be avoided. (PPSAA 10.5)</p>\n<p>Be careful, the <code data-lang=\"c\">sizeof(S) / sizeof(*S)</code> trick (recall <code data-lang=\"c\">*S</code> is simply <code data-lang=\"c\">S[0]</code>) will not work if the array <code data-lang=\"c\">S</code> is created in a different scope.  For example, if we create <code data-lang=\"c\">S</code> in <code data-lang=\"c\">main</code> and pass <code data-lang=\"c\">S</code> to another function, <code data-lang=\"c\">S</code> will just be a pointer, not an array, so <code data-lang=\"c\">sizeof(S) = sizeof(void *) =</code> 4 bytes (32-bit) or 8 bytes (64-bit).</p>",
            "notes_rendered": ""
          },
          {
            "id": "8ff29f9b-53b5-44dc-ad7a-16aa06d7d3df",
            "title": "treeops.h (Figures 10.13-15)",
            "type": 0,
            "layout": 2,
            "feedback_style": 0,
            "purpose": "",
            "content_raw": "#markdown\n\nThe `treeops.h` library has been included here, implementing a polymorphic binary search tree, along with an example program.  Feel free to run it and inspect the code to see how it works.\n\nRecall that in a binary search tree (BST), for any given node with data $$x$$, the data in its left child, $$l$$ is $$l < x$$ (smaller), and the data in its right child, $$r$$ is $$r > x$$ (greater).  \n\n```path:treeops.h;norun;eg:treeops\n/* tree operations\n * Alistair Moffat, PPSAA, Chapter 10, December 2012\n * (c) University of Melbourne */\ntypedef struct node node_t;\n\nstruct node {\n\tvoid *data;              /* ptr to stored structure */\n\tnode_t *left;            /* left subtree of node */\n\tnode_t *rght;            /* right subtree of node */\n};\n\ntypedef struct {\n\tnode_t *root;            /* root node of the tree */\n\tint (*cmp)(void*,void*); /* function pointer */\n} tree_t;\n\n/* prototypes for the functions in this library */\ntree_t *make_empty_tree(int func(void*,void*));\nint is_empty_tree(tree_t *tree);\nvoid *search_tree(tree_t *tree, void *key);\ntree_t *insert_in_order(tree_t *tree, void *value);\nvoid traverse_tree(tree_t *tree, void action(void*));\nvoid free_tree(tree_t *tree);\n```\n```path:treeops.c;norun;eg:last\n/* tree operations\n * Alistair Moffat, PPSAA, Chapter 10, December 2012\n * (c) University of Melbourne */\n#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"treeops.h\"\n\ntree_t\n*make_empty_tree(int func(void*,void*)) {\n\ttree_t *tree;\n\ttree = malloc(sizeof(*tree));\n\tassert(tree!=NULL);\n\t/* initialize tree to empty */\n\ttree->root = NULL;\n\t/* and save the supplied function pointer */\n\ttree->cmp = func;        \n\treturn tree;\n}\n\nint\nis_empty_tree(tree_t *tree) {\n\tassert(tree!=NULL);\n\treturn tree->root==NULL;\n}\n\nstatic void *recursive_search_tree(node_t*, void*,\n\t\tint(void*,void*));\n\nstatic void\n*recursive_search_tree(node_t *root,\n\t\tvoid *key, int cmp(void*,void*)) {\n\tint outcome;\n\tif (!root) {\n\t\treturn NULL;\n\t}\n\tif ((outcome=cmp(key, root->data)) < 0) {\n\t\treturn recursive_search_tree(root->left, key, cmp);\n\t} else if (outcome > 0) {\n\t\treturn recursive_search_tree(root->rght, key, cmp);\n\t} else {\n\t\t/* hey, must have found it! */\n\t\treturn root->data;\n\t}\n}\n\n/* Returns a pointer to the tree node storing object \"key\",\n   if it exists, otherwise returns a NULL pointer. */\nvoid\n*search_tree(tree_t *tree, void *key) {\n\tassert(tree!=NULL);\n\treturn recursive_search_tree(tree->root, key, tree->cmp);\n}\n\nstatic node_t *recursive_insert(node_t*, node_t*,\n\t\tint(void*,void*));\n\nstatic node_t\n*recursive_insert(node_t *root, node_t *new,\n\t\tint cmp(void*,void*)) {\n\tif (root==NULL) {\n\t\treturn new;\n\t} else if (cmp(new->data, root->data) < 0) {\n\t\troot->left = recursive_insert(root->left, new, cmp);\n\t} else {\n\t\troot->rght = recursive_insert(root->rght, new, cmp);\n\t}\n\treturn root;\n}\n\n/* Returns a pointer to an altered tree that now includes\n   the object \"value\" in its correct location. */\ntree_t\n*insert_in_order(tree_t *tree, void *value) {\n\tnode_t *new;\n\t/* make the new node */\n\tnew = malloc(sizeof(*new));\n\tassert(tree!=NULL && new!=NULL);\n\tnew->data = value;\n\tnew->left = new->rght = NULL;\n\t/* and insert it into the tree */\n\ttree->root = recursive_insert(tree->root, new,\n\t\ttree->cmp);\n\treturn tree;\n}\n\nstatic void recursive_traverse(node_t*, void action(void*));\n\nstatic void\nrecursive_traverse(node_t *root, void action(void*)) {\n\tif (root) {\n\t\trecursive_traverse(root->left, action);\n\t\taction(root->data);\n\t\trecursive_traverse(root->rght, action);\n\t}\n}\n\n/* Applies the \"action\" at every node in the tree, in\n   the order determined by the cmp function. */\nvoid\ntraverse_tree(tree_t *tree, void action(void*)) {\n\tassert(tree!=NULL);\n\trecursive_traverse(tree->root, action);\n}\n\nstatic void recursive_free_tree(node_t*);\n\nstatic void\nrecursive_free_tree(node_t *root) {\n\tif (root) {\n\t\trecursive_free_tree(root->left);\n\t\trecursive_free_tree(root->rght);\n\t\tfree(root);\n\t}\n}\n\n/* Release all memory space associated with the tree\n   structure. */\nvoid\nfree_tree(tree_t *tree) {\n\tassert(tree!=NULL);\n\trecursive_free_tree(tree->root);\n\tfree(tree);\n}\n```\n```eg:last;path:getword.h\n#define MAXCHARS 1000\ntypedef char word_t[MAXCHARS];\n\nint getword(char W[], int limit);\n// implementation hidden\n```\n```eg:last;path:getword.c;hidden\n#include <stdio.h>\n#include <ctype.h>\n\n/* Extract a single word out of the standard input, of not\n   more than limit characters. Argument array W must be\n   limit+1 characters or bigger. */\nint\ngetword(char W[], int limit) {\n\tint c, len=0;\n\t/* first, skip over any non alphabetics */\n\twhile ((c=getchar())!=EOF && !isalpha(c)) {\n\t\t/* do nothing more */\n\t}\n\tif (c==EOF) {\n\t\treturn EOF;\n\t}\n\t/* ok, first character of next word has been found */\n\tW[len++] = c;\n\twhile (len<limit && (c=getchar())!=EOF && isalpha(c)) {\n\t\t/* another character to be stored */\n\t\tW[len++] = c;\n\t}\n\t/* now close off the string */\n\tW[len] = '\\0';\n\treturn 0;\n}\n```\n```eg:last\n/* tree operations example program\n * Alistair Moffat, PPSAA, Chapter 10, December 2012\n * (c) University of Melbourne */\n/* Use a binary search tree to count words, and print\n   a sorted list of words and their frequencies.\n*/\n#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <string.h>\n#include \"treeops.h\"\n#include \"getword.h\"\n\ntypedef struct {\n\tchar *word;      /* pointer to a word */\n\tint  freq;       /* frequency of that word */\n} data_t;\n\nint\ncompare_string_parts(void *x1, void *x2) {\n\tdata_t *p1=x1, *p2=x2;\n\treturn strcmp(p1->word, p2->word);\n}\n\nvoid\nprint_then_free(void *x) {\n\tdata_t *p=x;\n\tprintf(\"%4d  %s\\n\", p->freq, p->word);\n\tfree(p->word);\n\tfree(p);\n}\n\nint\nmain(int argc, char *argv[]) {\n\tdata_t *new, *locn;\n\ttree_t *tree;\n\tword_t oneword;\n\ttree = make_empty_tree(compare_string_parts);\n\twhile (getword(oneword, MAXCHARS) != EOF) {\n\t\tnew = malloc(sizeof(*new));\n\t\tassert(new!=NULL);\n\t\tnew->word = oneword;\n\t\tnew->freq = 1;\n\t\tlocn = search_tree(tree, new);\n\t\tif (!locn) {\n\t\t\t/* not in tree, so create a new string */\n\t\t\tnew->word = malloc(1+strlen(oneword));\n\t\t\tassert(new->word!=NULL);\n\t\t\tstrcpy(new->word, oneword);\n\t\t\t/* and insert into tree */\n\t\t\ttree = insert_in_order(tree, new);\n\t\t} else {\n\t\t\t/* already in tree, so increment count */\n\t\t\tlocn->freq += 1;\n\t\t\t/* and release the temporary node */\n\t\t\tfree(new);\n\t\t}\n\t}\n\t/* now print all the words, freeing on the way */\n\ttraverse_tree(tree, print_then_free);\n\t/* and release the tree itself */\n\tfree_tree(tree);\n\ttree = NULL;\n\t/* ta daaa! */\n\treturn 0;\n}\n```\n```eg:last;path:Makefile;readonly;hidden;\nCC = clang\nCFLAGS = -Wall -Wno-unused-parameter -std=c11\n\nPROGRAM = program\nSOURCE_FILES = $(shell find . -type f -name '*.c')\nOBJECT_FILES = $(SOURCE_FILES:.c=.o)\n\n.PHONY: all build clean run\n\nall: build\n\nbuild: $(PROGRAM)\n\nclean:\n\trm -f $(PROGRAM) $(OBJECT_FILES)\n\nrun: build\n\t./$(PROGRAM)\n\n$(PROGRAM): $(OBJECT_FILES)\n\t$(CC) -o $@ $^ $(LDFLAGS)\n```\n",
            "rows": [
              {
                "left": "#markdown\n\nThe `treeops.h` library has been included here, implementing a polymorphic binary search tree, along with an example program.  Feel free to run it and inspect the code to see how it works.\n\nRecall that in a binary search tree (BST), for any given node with data $$x$$, the data in its left child, $$l$$ is $$l < x$$ (smaller), and the data in its right child, $$r$$ is $$r > x$$ (greater).  \n\n```path:treeops.h;norun;eg:treeops\n/* tree operations\n * Alistair Moffat, PPSAA, Chapter 10, December 2012\n * (c) University of Melbourne */\ntypedef struct node node_t;\n\nstruct node {\n\tvoid *data;              /* ptr to stored structure */\n\tnode_t *left;            /* left subtree of node */\n\tnode_t *rght;            /* right subtree of node */\n};\n\ntypedef struct {\n\tnode_t *root;            /* root node of the tree */\n\tint (*cmp)(void*,void*); /* function pointer */\n} tree_t;\n\n/* prototypes for the functions in this library */\ntree_t *make_empty_tree(int func(void*,void*));\nint is_empty_tree(tree_t *tree);\nvoid *search_tree(tree_t *tree, void *key);\ntree_t *insert_in_order(tree_t *tree, void *value);\nvoid traverse_tree(tree_t *tree, void action(void*));\nvoid free_tree(tree_t *tree);\n```\n```path:treeops.c;norun;eg:last\n/* tree operations\n * Alistair Moffat, PPSAA, Chapter 10, December 2012\n * (c) University of Melbourne */\n#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"treeops.h\"\n\ntree_t\n*make_empty_tree(int func(void*,void*)) {\n\ttree_t *tree;\n\ttree = malloc(sizeof(*tree));\n\tassert(tree!=NULL);\n\t/* initialize tree to empty */\n\ttree->root = NULL;\n\t/* and save the supplied function pointer */\n\ttree->cmp = func;        \n\treturn tree;\n}\n\nint\nis_empty_tree(tree_t *tree) {\n\tassert(tree!=NULL);\n\treturn tree->root==NULL;\n}\n\nstatic void *recursive_search_tree(node_t*, void*,\n\t\tint(void*,void*));\n\nstatic void\n*recursive_search_tree(node_t *root,\n\t\tvoid *key, int cmp(void*,void*)) {\n\tint outcome;\n\tif (!root) {\n\t\treturn NULL;\n\t}\n\tif ((outcome=cmp(key, root->data)) < 0) {\n\t\treturn recursive_search_tree(root->left, key, cmp);\n\t} else if (outcome > 0) {\n\t\treturn recursive_search_tree(root->rght, key, cmp);\n\t} else {\n\t\t/* hey, must have found it! */\n\t\treturn root->data;\n\t}\n}\n\n/* Returns a pointer to the tree node storing object \"key\",\n   if it exists, otherwise returns a NULL pointer. */\nvoid\n*search_tree(tree_t *tree, void *key) {\n\tassert(tree!=NULL);\n\treturn recursive_search_tree(tree->root, key, tree->cmp);\n}\n\nstatic node_t *recursive_insert(node_t*, node_t*,\n\t\tint(void*,void*));\n\nstatic node_t\n*recursive_insert(node_t *root, node_t *new,\n\t\tint cmp(void*,void*)) {\n\tif (root==NULL) {\n\t\treturn new;\n\t} else if (cmp(new->data, root->data) < 0) {\n\t\troot->left = recursive_insert(root->left, new, cmp);\n\t} else {\n\t\troot->rght = recursive_insert(root->rght, new, cmp);\n\t}\n\treturn root;\n}\n\n/* Returns a pointer to an altered tree that now includes\n   the object \"value\" in its correct location. */\ntree_t\n*insert_in_order(tree_t *tree, void *value) {\n\tnode_t *new;\n\t/* make the new node */\n\tnew = malloc(sizeof(*new));\n\tassert(tree!=NULL && new!=NULL);\n\tnew->data = value;\n\tnew->left = new->rght = NULL;\n\t/* and insert it into the tree */\n\ttree->root = recursive_insert(tree->root, new,\n\t\ttree->cmp);\n\treturn tree;\n}\n\nstatic void recursive_traverse(node_t*, void action(void*));\n\nstatic void\nrecursive_traverse(node_t *root, void action(void*)) {\n\tif (root) {\n\t\trecursive_traverse(root->left, action);\n\t\taction(root->data);\n\t\trecursive_traverse(root->rght, action);\n\t}\n}\n\n/* Applies the \"action\" at every node in the tree, in\n   the order determined by the cmp function. */\nvoid\ntraverse_tree(tree_t *tree, void action(void*)) {\n\tassert(tree!=NULL);\n\trecursive_traverse(tree->root, action);\n}\n\nstatic void recursive_free_tree(node_t*);\n\nstatic void\nrecursive_free_tree(node_t *root) {\n\tif (root) {\n\t\trecursive_free_tree(root->left);\n\t\trecursive_free_tree(root->rght);\n\t\tfree(root);\n\t}\n}\n\n/* Release all memory space associated with the tree\n   structure. */\nvoid\nfree_tree(tree_t *tree) {\n\tassert(tree!=NULL);\n\trecursive_free_tree(tree->root);\n\tfree(tree);\n}\n```\n```eg:last;path:getword.h\n#define MAXCHARS 1000\ntypedef char word_t[MAXCHARS];\n\nint getword(char W[], int limit);\n// implementation hidden\n```\n```eg:last;path:getword.c;hidden\n#include <stdio.h>\n#include <ctype.h>\n\n/* Extract a single word out of the standard input, of not\n   more than limit characters. Argument array W must be\n   limit+1 characters or bigger. */\nint\ngetword(char W[], int limit) {\n\tint c, len=0;\n\t/* first, skip over any non alphabetics */\n\twhile ((c=getchar())!=EOF && !isalpha(c)) {\n\t\t/* do nothing more */\n\t}\n\tif (c==EOF) {\n\t\treturn EOF;\n\t}\n\t/* ok, first character of next word has been found */\n\tW[len++] = c;\n\twhile (len<limit && (c=getchar())!=EOF && isalpha(c)) {\n\t\t/* another character to be stored */\n\t\tW[len++] = c;\n\t}\n\t/* now close off the string */\n\tW[len] = '\\0';\n\treturn 0;\n}\n```\n```eg:last\n/* tree operations example program\n * Alistair Moffat, PPSAA, Chapter 10, December 2012\n * (c) University of Melbourne */\n/* Use a binary search tree to count words, and print\n   a sorted list of words and their frequencies.\n*/\n#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <string.h>\n#include \"treeops.h\"\n#include \"getword.h\"\n\ntypedef struct {\n\tchar *word;      /* pointer to a word */\n\tint  freq;       /* frequency of that word */\n} data_t;\n\nint\ncompare_string_parts(void *x1, void *x2) {\n\tdata_t *p1=x1, *p2=x2;\n\treturn strcmp(p1->word, p2->word);\n}\n\nvoid\nprint_then_free(void *x) {\n\tdata_t *p=x;\n\tprintf(\"%4d  %s\\n\", p->freq, p->word);\n\tfree(p->word);\n\tfree(p);\n}\n\nint\nmain(int argc, char *argv[]) {\n\tdata_t *new, *locn;\n\ttree_t *tree;\n\tword_t oneword;\n\ttree = make_empty_tree(compare_string_parts);\n\twhile (getword(oneword, MAXCHARS) != EOF) {\n\t\tnew = malloc(sizeof(*new));\n\t\tassert(new!=NULL);\n\t\tnew->word = oneword;\n\t\tnew->freq = 1;\n\t\tlocn = search_tree(tree, new);\n\t\tif (!locn) {\n\t\t\t/* not in tree, so create a new string */\n\t\t\tnew->word = malloc(1+strlen(oneword));\n\t\t\tassert(new->word!=NULL);\n\t\t\tstrcpy(new->word, oneword);\n\t\t\t/* and insert into tree */\n\t\t\ttree = insert_in_order(tree, new);\n\t\t} else {\n\t\t\t/* already in tree, so increment count */\n\t\t\tlocn->freq += 1;\n\t\t\t/* and release the temporary node */\n\t\t\tfree(new);\n\t\t}\n\t}\n\t/* now print all the words, freeing on the way */\n\ttraverse_tree(tree, print_then_free);\n\t/* and release the tree itself */\n\tfree_tree(tree);\n\ttree = NULL;\n\t/* ta daaa! */\n\treturn 0;\n}\n```\n```eg:last;path:Makefile;readonly;hidden;\nCC = clang\nCFLAGS = -Wall -Wno-unused-parameter -std=c11\n\nPROGRAM = program\nSOURCE_FILES = $(shell find . -type f -name '*.c')\nOBJECT_FILES = $(SOURCE_FILES:.c=.o)\n\n.PHONY: all build clean run\n\nall: build\n\nbuild: $(PROGRAM)\n\nclean:\n\trm -f $(PROGRAM) $(OBJECT_FILES)\n\nrun: build\n\t./$(PROGRAM)\n\n$(PROGRAM): $(OBJECT_FILES)\n\t$(CC) -o $@ $^ $(LDFLAGS)\n```\n"
              }
            ],
            "content_rendered": "<p>The <code data-lang=\"c\">treeops.h</code> library has been included here, implementing a polymorphic binary search tree, along with an example program.  Feel free to run it and inspect the code to see how it works.</p>\n<p>Recall that in a binary search tree (BST), for any given node with data $$x$$, the data in its left child, $$l$$ is $$l &lt; x$$ (smaller), and the data in its right child, $$r$$ is $$r &gt; x$$ (greater).</p>\n<pre class=\"js-file-editor\" data-eg-id=\"treeops\" data-path=\"treeops.h\" data-runnable=\"false\"><code data-lang=\"c\">/* tree operations\n * Alistair Moffat, PPSAA, Chapter 10, December 2012\n * (c) University of Melbourne */\ntypedef struct node node_t;\n\nstruct node {\n\tvoid *data;              /* ptr to stored structure */\n\tnode_t *left;            /* left subtree of node */\n\tnode_t *rght;            /* right subtree of node */\n};\n\ntypedef struct {\n\tnode_t *root;            /* root node of the tree */\n\tint (*cmp)(void*,void*); /* function pointer */\n} tree_t;\n\n/* prototypes for the functions in this library */\ntree_t *make_empty_tree(int func(void*,void*));\nint is_empty_tree(tree_t *tree);\nvoid *search_tree(tree_t *tree, void *key);\ntree_t *insert_in_order(tree_t *tree, void *value);\nvoid traverse_tree(tree_t *tree, void action(void*));\nvoid free_tree(tree_t *tree);\n</code></pre>\n<pre class=\"js-file-editor\" data-eg-id=\"treeops\" data-path=\"treeops.c\" data-runnable=\"false\"><code data-lang=\"c\">/* tree operations\n * Alistair Moffat, PPSAA, Chapter 10, December 2012\n * (c) University of Melbourne */\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;assert.h&gt;\n#include &quot;treeops.h&quot;\n\ntree_t\n*make_empty_tree(int func(void*,void*)) {\n\ttree_t *tree;\n\ttree = malloc(sizeof(*tree));\n\tassert(tree!=NULL);\n\t/* initialize tree to empty */\n\ttree-&gt;root = NULL;\n\t/* and save the supplied function pointer */\n\ttree-&gt;cmp = func;        \n\treturn tree;\n}\n\nint\nis_empty_tree(tree_t *tree) {\n\tassert(tree!=NULL);\n\treturn tree-&gt;root==NULL;\n}\n\nstatic void *recursive_search_tree(node_t*, void*,\n\t\tint(void*,void*));\n\nstatic void\n*recursive_search_tree(node_t *root,\n\t\tvoid *key, int cmp(void*,void*)) {\n\tint outcome;\n\tif (!root) {\n\t\treturn NULL;\n\t}\n\tif ((outcome=cmp(key, root-&gt;data)) &lt; 0) {\n\t\treturn recursive_search_tree(root-&gt;left, key, cmp);\n\t} else if (outcome &gt; 0) {\n\t\treturn recursive_search_tree(root-&gt;rght, key, cmp);\n\t} else {\n\t\t/* hey, must have found it! */\n\t\treturn root-&gt;data;\n\t}\n}\n\n/* Returns a pointer to the tree node storing object &quot;key&quot;,\n   if it exists, otherwise returns a NULL pointer. */\nvoid\n*search_tree(tree_t *tree, void *key) {\n\tassert(tree!=NULL);\n\treturn recursive_search_tree(tree-&gt;root, key, tree-&gt;cmp);\n}\n\nstatic node_t *recursive_insert(node_t*, node_t*,\n\t\tint(void*,void*));\n\nstatic node_t\n*recursive_insert(node_t *root, node_t *new,\n\t\tint cmp(void*,void*)) {\n\tif (root==NULL) {\n\t\treturn new;\n\t} else if (cmp(new-&gt;data, root-&gt;data) &lt; 0) {\n\t\troot-&gt;left = recursive_insert(root-&gt;left, new, cmp);\n\t} else {\n\t\troot-&gt;rght = recursive_insert(root-&gt;rght, new, cmp);\n\t}\n\treturn root;\n}\n\n/* Returns a pointer to an altered tree that now includes\n   the object &quot;value&quot; in its correct location. */\ntree_t\n*insert_in_order(tree_t *tree, void *value) {\n\tnode_t *new;\n\t/* make the new node */\n\tnew = malloc(sizeof(*new));\n\tassert(tree!=NULL &amp;&amp; new!=NULL);\n\tnew-&gt;data = value;\n\tnew-&gt;left = new-&gt;rght = NULL;\n\t/* and insert it into the tree */\n\ttree-&gt;root = recursive_insert(tree-&gt;root, new,\n\t\ttree-&gt;cmp);\n\treturn tree;\n}\n\nstatic void recursive_traverse(node_t*, void action(void*));\n\nstatic void\nrecursive_traverse(node_t *root, void action(void*)) {\n\tif (root) {\n\t\trecursive_traverse(root-&gt;left, action);\n\t\taction(root-&gt;data);\n\t\trecursive_traverse(root-&gt;rght, action);\n\t}\n}\n\n/* Applies the &quot;action&quot; at every node in the tree, in\n   the order determined by the cmp function. */\nvoid\ntraverse_tree(tree_t *tree, void action(void*)) {\n\tassert(tree!=NULL);\n\trecursive_traverse(tree-&gt;root, action);\n}\n\nstatic void recursive_free_tree(node_t*);\n\nstatic void\nrecursive_free_tree(node_t *root) {\n\tif (root) {\n\t\trecursive_free_tree(root-&gt;left);\n\t\trecursive_free_tree(root-&gt;rght);\n\t\tfree(root);\n\t}\n}\n\n/* Release all memory space associated with the tree\n   structure. */\nvoid\nfree_tree(tree_t *tree) {\n\tassert(tree!=NULL);\n\trecursive_free_tree(tree-&gt;root);\n\tfree(tree);\n}\n</code></pre>\n<pre class=\"js-file-editor\" data-eg-id=\"treeops\" data-path=\"getword.h\"><code data-lang=\"c\">#define MAXCHARS 1000\ntypedef char word_t[MAXCHARS];\n\nint getword(char W[], int limit);\n// implementation hidden\n</code></pre>\n<pre class=\"js-file-editor\" data-eg-id=\"treeops\" data-path=\"getword.c\" style=\"display: none\"><code data-lang=\"c\">#include &lt;stdio.h&gt;\n#include &lt;ctype.h&gt;\n\n/* Extract a single word out of the standard input, of not\n   more than limit characters. Argument array W must be\n   limit+1 characters or bigger. */\nint\ngetword(char W[], int limit) {\n\tint c, len=0;\n\t/* first, skip over any non alphabetics */\n\twhile ((c=getchar())!=EOF &amp;&amp; !isalpha(c)) {\n\t\t/* do nothing more */\n\t}\n\tif (c==EOF) {\n\t\treturn EOF;\n\t}\n\t/* ok, first character of next word has been found */\n\tW[len++] = c;\n\twhile (len&lt;limit &amp;&amp; (c=getchar())!=EOF &amp;&amp; isalpha(c)) {\n\t\t/* another character to be stored */\n\t\tW[len++] = c;\n\t}\n\t/* now close off the string */\n\tW[len] = '\\0';\n\treturn 0;\n}\n</code></pre>\n<pre class=\"js-editor\" data-eg-id=\"treeops\"><code data-lang=\"c\">/* tree operations example program\n * Alistair Moffat, PPSAA, Chapter 10, December 2012\n * (c) University of Melbourne */\n/* Use a binary search tree to count words, and print\n   a sorted list of words and their frequencies.\n*/\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;assert.h&gt;\n#include &lt;string.h&gt;\n#include &quot;treeops.h&quot;\n#include &quot;getword.h&quot;\n\ntypedef struct {\n\tchar *word;      /* pointer to a word */\n\tint  freq;       /* frequency of that word */\n} data_t;\n\nint\ncompare_string_parts(void *x1, void *x2) {\n\tdata_t *p1=x1, *p2=x2;\n\treturn strcmp(p1-&gt;word, p2-&gt;word);\n}\n\nvoid\nprint_then_free(void *x) {\n\tdata_t *p=x;\n\tprintf(&quot;%4d  %s\\n&quot;, p-&gt;freq, p-&gt;word);\n\tfree(p-&gt;word);\n\tfree(p);\n}\n\nint\nmain(int argc, char *argv[]) {\n\tdata_t *new, *locn;\n\ttree_t *tree;\n\tword_t oneword;\n\ttree = make_empty_tree(compare_string_parts);\n\twhile (getword(oneword, MAXCHARS) != EOF) {\n\t\tnew = malloc(sizeof(*new));\n\t\tassert(new!=NULL);\n\t\tnew-&gt;word = oneword;\n\t\tnew-&gt;freq = 1;\n\t\tlocn = search_tree(tree, new);\n\t\tif (!locn) {\n\t\t\t/* not in tree, so create a new string */\n\t\t\tnew-&gt;word = malloc(1+strlen(oneword));\n\t\t\tassert(new-&gt;word!=NULL);\n\t\t\tstrcpy(new-&gt;word, oneword);\n\t\t\t/* and insert into tree */\n\t\t\ttree = insert_in_order(tree, new);\n\t\t} else {\n\t\t\t/* already in tree, so increment count */\n\t\t\tlocn-&gt;freq += 1;\n\t\t\t/* and release the temporary node */\n\t\t\tfree(new);\n\t\t}\n\t}\n\t/* now print all the words, freeing on the way */\n\ttraverse_tree(tree, print_then_free);\n\t/* and release the tree itself */\n\tfree_tree(tree);\n\ttree = NULL;\n\t/* ta daaa! */\n\treturn 0;\n}\n</code></pre>\n<pre class=\"js-file-editor\" data-eg-id=\"treeops\" data-path=\"Makefile\" data-readonly=\"true\" style=\"display: none\"><code data-lang=\"c\">CC = clang\nCFLAGS = -Wall -Wno-unused-parameter -std=c11\n\nPROGRAM = program\nSOURCE_FILES = $(shell find . -type f -name '*.c')\nOBJECT_FILES = $(SOURCE_FILES:.c=.o)\n\n.PHONY: all build clean run\n\nall: build\n\nbuild: $(PROGRAM)\n\nclean:\n\trm -f $(PROGRAM) $(OBJECT_FILES)\n\nrun: build\n\t./$(PROGRAM)\n\n$(PROGRAM): $(OBJECT_FILES)\n\t$(CC) -o $@ $^ $(LDFLAGS)\n</code></pre>",
            "notes_rendered": ""
          },
          {
            "id": "5fd15c68-e038-408b-be13-a4b5fe132d71",
            "title": "Ex10.04-20",
            "type": 1,
            "layout": 0,
            "feedback_style": 0,
            "purpose": "",
            "problem_id": 15560,
            "authoring_notes": "",
            "tutor_notes": ""
          }
        ]
      }
    ],
    "review_log": [
      {
        "timestamp": 1644960395,
        "comments": "Cloned from unimelb-cprog-core-chapter10",
        "user_id": 41550784,
        "authoring_state": 0,
        "full_name": "Bryn Jeffries"
      },
      {
        "timestamp": 1644961493,
        "comments": "Cloned from cprog-core",
        "user_id": 41550784,
        "authoring_state": 3,
        "full_name": "Bryn Jeffries"
      },
      {
        "timestamp": 1652153440,
        "comments": "add treeops",
        "user_id": 41827374,
        "authoring_state": 3,
        "full_name": "Liam Saliba"
      },
      {
        "timestamp": 1652153519,
        "comments": "fix",
        "user_id": 41827374,
        "authoring_state": 3,
        "full_name": "Liam Saliba"
      },
      {
        "timestamp": 1652153627,
        "comments": ".",
        "user_id": 41827374,
        "authoring_state": 3,
        "full_name": "Liam Saliba"
      },
      {
        "timestamp": 1652153688,
        "comments": "add getword.h",
        "user_id": 41827374,
        "authoring_state": 3,
        "full_name": "Liam Saliba"
      },
      {
        "timestamp": 1652153786,
        "comments": "add typedef",
        "user_id": 41827374,
        "authoring_state": 3,
        "full_name": "Liam Saliba"
      },
      {
        "timestamp": 1652153811,
        "comments": "maxchars",
        "user_id": 41827374,
        "authoring_state": 3,
        "full_name": "Liam Saliba"
      },
      {
        "timestamp": 1652154524,
        "comments": ".",
        "user_id": 41827374,
        "authoring_state": 3,
        "full_name": "Liam Saliba"
      },
      {
        "timestamp": 1652154785,
        "comments": ".",
        "user_id": 41827374,
        "authoring_state": 3,
        "full_name": "Liam Saliba"
      },
      {
        "timestamp": 1652155153,
        "comments": ".",
        "user_id": 41827374,
        "authoring_state": 3,
        "full_name": "Liam Saliba"
      },
      {
        "timestamp": 1652239882,
        "comments": "add figures 10.10-11",
        "user_id": 41827374,
        "authoring_state": 3,
        "full_name": "Liam Saliba"
      },
      {
        "timestamp": 1652240016,
        "comments": "notes only",
        "user_id": 41827374,
        "authoring_state": 3,
        "full_name": "Liam Saliba"
      },
      {
        "timestamp": 1652240055,
        "comments": ".",
        "user_id": 41827374,
        "authoring_state": 3,
        "full_name": "Liam Saliba"
      },
      {
        "timestamp": 1652240422,
        "comments": ".",
        "user_id": 41827374,
        "authoring_state": 3,
        "full_name": "Liam Saliba"
      },
      {
        "timestamp": 1652240692,
        "comments": "finished",
        "user_id": 41827374,
        "authoring_state": 3,
        "full_name": "Liam Saliba"
      }
    ],
    "concepts": [],
    "owner_institution": 114092,
    "updated_at": 1652240692,
    "__schema_version": 2
  }
}
